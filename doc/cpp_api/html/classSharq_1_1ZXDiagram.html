<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sharq: Sharq::ZXDiagram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sharq
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Sharq</b></li><li class="navelem"><a class="el" href="classSharq_1_1ZXDiagram.html">ZXDiagram</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSharq_1_1ZXDiagram-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sharq::ZXDiagram Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ZX-diagram.  
 <a href="classSharq_1_1ZXDiagram.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="zx_8h_source.html">zx.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a469c13bb8ac50c50a279cc35f419da3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a469c13bb8ac50c50a279cc35f419da3a">ZXDiagram</a> (const uint32_t <a class="el" href="classSharq_1_1ZXDiagram.html#a295575ed9eaa0dce6c1fe3d35dc20f78">qubit_num</a>=1)</td></tr>
<tr class="memdesc:a469c13bb8ac50c50a279cc35f419da3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a>  <a href="classSharq_1_1ZXDiagram.html#a469c13bb8ac50c50a279cc35f419da3a">More...</a><br /></td></tr>
<tr class="separator:a469c13bb8ac50c50a279cc35f419da3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec429e9860b3ff29683451df003cb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a32ec429e9860b3ff29683451df003cb7">ZXDiagram</a> (const <a class="el" href="classSharq_1_1ZXDiagram.html">ZXDiagram</a> &amp;zx)</td></tr>
<tr class="memdesc:a32ec429e9860b3ff29683451df003cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a>  <a href="classSharq_1_1ZXDiagram.html#a32ec429e9860b3ff29683451df003cb7">More...</a><br /></td></tr>
<tr class="separator:a32ec429e9860b3ff29683451df003cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f7c32e4f8a200443585b4406610c15"><td class="memItemLeft" align="right" valign="top"><a id="a96f7c32e4f8a200443585b4406610c15"></a>
<a class="el" href="zx_8h.html#aebf0fc24b275ec10e880ea29554b16cc">ZXDiagramKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a96f7c32e4f8a200443585b4406610c15">kind</a> () const</td></tr>
<tr class="memdesc:a96f7c32e4f8a200443585b4406610c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the kind_ <br /></td></tr>
<tr class="separator:a96f7c32e4f8a200443585b4406610c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295575ed9eaa0dce6c1fe3d35dc20f78"><td class="memItemLeft" align="right" valign="top"><a id="a295575ed9eaa0dce6c1fe3d35dc20f78"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a295575ed9eaa0dce6c1fe3d35dc20f78">qubit_num</a> () const</td></tr>
<tr class="memdesc:a295575ed9eaa0dce6c1fe3d35dc20f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the qubit_num_ <br /></td></tr>
<tr class="separator:a295575ed9eaa0dce6c1fe3d35dc20f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d3dfd0b2edeb08e895c6064ed8c439"><td class="memItemLeft" align="right" valign="top"><a id="ab5d3dfd0b2edeb08e895c6064ed8c439"></a>
std::vector&lt; <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab5d3dfd0b2edeb08e895c6064ed8c439">nodes</a> () const</td></tr>
<tr class="memdesc:ab5d3dfd0b2edeb08e895c6064ed8c439"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the nodes_ <br /></td></tr>
<tr class="separator:ab5d3dfd0b2edeb08e895c6064ed8c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dd87a93fb84d3bcc11d0aa01288988"><td class="memItemLeft" align="right" valign="top"><a id="a29dd87a93fb84d3bcc11d0aa01288988"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a29dd87a93fb84d3bcc11d0aa01288988">inputs</a> () const</td></tr>
<tr class="memdesc:a29dd87a93fb84d3bcc11d0aa01288988"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the inputs_ <br /></td></tr>
<tr class="separator:a29dd87a93fb84d3bcc11d0aa01288988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a59edfbf37f69dcc918ccae391f528"><td class="memItemLeft" align="right" valign="top"><a id="a45a59edfbf37f69dcc918ccae391f528"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a45a59edfbf37f69dcc918ccae391f528">outputs</a> () const</td></tr>
<tr class="memdesc:a45a59edfbf37f69dcc918ccae391f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the outputs_ <br /></td></tr>
<tr class="separator:a45a59edfbf37f69dcc918ccae391f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39417604b6702a9a3f7ad7c2c4456f0"><td class="memItemLeft" align="right" valign="top"><a id="ae39417604b6702a9a3f7ad7c2c4456f0"></a>
std::vector&lt; std::vector&lt; <a class="el" href="classSharq_1_1ZXEdge.html">ZXEdge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae39417604b6702a9a3f7ad7c2c4456f0">adj_mat</a> () const</td></tr>
<tr class="memdesc:ae39417604b6702a9a3f7ad7c2c4456f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the adj_mat_ <br /></td></tr>
<tr class="separator:ae39417604b6702a9a3f7ad7c2c4456f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03df80fd6706bd54cd77600edf34c552"><td class="memItemLeft" align="right" valign="top"><a id="a03df80fd6706bd54cd77600edf34c552"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a03df80fd6706bd54cd77600edf34c552">kind</a> (const <a class="el" href="zx_8h.html#aebf0fc24b275ec10e880ea29554b16cc">ZXDiagramKind</a> kind)</td></tr>
<tr class="memdesc:a03df80fd6706bd54cd77600edf34c552"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the kind_ <br /></td></tr>
<tr class="separator:a03df80fd6706bd54cd77600edf34c552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9b4de730795d4814b804ec3e7b7cf"><td class="memItemLeft" align="right" valign="top"><a id="a27d9b4de730795d4814b804ec3e7b7cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a27d9b4de730795d4814b804ec3e7b7cf">qubit_num</a> (const uint32_t qubit_num)</td></tr>
<tr class="memdesc:a27d9b4de730795d4814b804ec3e7b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the qubit_num_ <br /></td></tr>
<tr class="separator:a27d9b4de730795d4814b804ec3e7b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af862d2331cdbd6bf583f8774aa0d75d6"><td class="memItemLeft" align="right" valign="top"><a id="af862d2331cdbd6bf583f8774aa0d75d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#af862d2331cdbd6bf583f8774aa0d75d6">nodes</a> (const std::vector&lt; <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:af862d2331cdbd6bf583f8774aa0d75d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the nodes_ <br /></td></tr>
<tr class="separator:af862d2331cdbd6bf583f8774aa0d75d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f2d5530305b968fc5f29394f6b694a"><td class="memItemLeft" align="right" valign="top"><a id="aa7f2d5530305b968fc5f29394f6b694a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#aa7f2d5530305b968fc5f29394f6b694a">inputs</a> (const std::vector&lt; uint32_t &gt; &amp;inputs)</td></tr>
<tr class="memdesc:aa7f2d5530305b968fc5f29394f6b694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the inputs_ <br /></td></tr>
<tr class="separator:aa7f2d5530305b968fc5f29394f6b694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbfbd7995ba1566c9030f4077b6ada6"><td class="memItemLeft" align="right" valign="top"><a id="a3dbfbd7995ba1566c9030f4077b6ada6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a3dbfbd7995ba1566c9030f4077b6ada6">outputs</a> (const std::vector&lt; uint32_t &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a3dbfbd7995ba1566c9030f4077b6ada6"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the outputs_ <br /></td></tr>
<tr class="separator:a3dbfbd7995ba1566c9030f4077b6ada6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf36bf6002aac6eff2781d8a46f2ced7"><td class="memItemLeft" align="right" valign="top"><a id="acf36bf6002aac6eff2781d8a46f2ced7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#acf36bf6002aac6eff2781d8a46f2ced7">adj_mat</a> (std::vector&lt; std::vector&lt; <a class="el" href="classSharq_1_1ZXEdge.html">ZXEdge</a> &gt;&gt; &amp;adj_mat)</td></tr>
<tr class="memdesc:acf36bf6002aac6eff2781d8a46f2ced7"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the adj_mat_ <br /></td></tr>
<tr class="separator:acf36bf6002aac6eff2781d8a46f2ced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7839768c8cea16f8215f598686ff7ce4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a7839768c8cea16f8215f598686ff7ce4">to_string</a> () const</td></tr>
<tr class="memdesc:a7839768c8cea16f8215f598686ff7ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object  <a href="classSharq_1_1ZXDiagram.html#a7839768c8cea16f8215f598686ff7ce4">More...</a><br /></td></tr>
<tr class="separator:a7839768c8cea16f8215f598686ff7ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7985caab7b5f86d5e98af28cdd0156"><td class="memItemLeft" align="right" valign="top"><a id="a6b7985caab7b5f86d5e98af28cdd0156"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a6b7985caab7b5f86d5e98af28cdd0156">show</a> () const</td></tr>
<tr class="memdesc:a6b7985caab7b5f86d5e98af28cdd0156"><td class="mdescLeft">&#160;</td><td class="mdescRight">show the ZX-diagram <br /></td></tr>
<tr class="separator:a6b7985caab7b5f86d5e98af28cdd0156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac417c0aafa5583b0d7c82b03c4a567c1"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ac417c0aafa5583b0d7c82b03c4a567c1">stats</a> () const</td></tr>
<tr class="memdesc:ac417c0aafa5583b0d7c82b03c4a567c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stats of the ZX-diagram  <a href="classSharq_1_1ZXDiagram.html#ac417c0aafa5583b0d7c82b03c4a567c1">More...</a><br /></td></tr>
<tr class="separator:ac417c0aafa5583b0d7c82b03c4a567c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b352d128be42e38e82e5ee2d1dc70aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a5b352d128be42e38e82e5ee2d1dc70aa">to_dot_file</a> (const std::string &amp;file_name) const</td></tr>
<tr class="memdesc:a5b352d128be42e38e82e5ee2d1dc70aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">save as a dot file  <a href="classSharq_1_1ZXDiagram.html#a5b352d128be42e38e82e5ee2d1dc70aa">More...</a><br /></td></tr>
<tr class="separator:a5b352d128be42e38e82e5ee2d1dc70aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e225cc9374d1e1267481e68ed0428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a8f2e225cc9374d1e1267481e68ed0428">to_svg_file</a> (const std::string &amp;file_name) const</td></tr>
<tr class="memdesc:a8f2e225cc9374d1e1267481e68ed0428"><td class="mdescLeft">&#160;</td><td class="mdescRight">save as a svg file  <a href="classSharq_1_1ZXDiagram.html#a8f2e225cc9374d1e1267481e68ed0428">More...</a><br /></td></tr>
<tr class="separator:a8f2e225cc9374d1e1267481e68ed0428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae618bf53bc381a0d97f25f5fc18cdba4"><td class="memItemLeft" align="right" valign="top"><a id="ae618bf53bc381a0d97f25f5fc18cdba4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae618bf53bc381a0d97f25f5fc18cdba4">spider_count</a> () const</td></tr>
<tr class="memdesc:ae618bf53bc381a0d97f25f5fc18cdba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a spider-count <br /></td></tr>
<tr class="separator:ae618bf53bc381a0d97f25f5fc18cdba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1879466af572112c9aa8e12bb985bba"><td class="memItemLeft" align="right" valign="top"><a id="ac1879466af572112c9aa8e12bb985bba"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ac1879466af572112c9aa8e12bb985bba">non_clifford_count</a> () const</td></tr>
<tr class="memdesc:ac1879466af572112c9aa8e12bb985bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a non-clifford-count <br /></td></tr>
<tr class="separator:ac1879466af572112c9aa8e12bb985bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff58bf0e205153ab6ef78cd823fe89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a43ff58bf0e205153ab6ef78cd823fe89">add_qgate</a> (const <a class="el" href="classSharq_1_1QGate.html">QGate</a> &amp;qgate)</td></tr>
<tr class="memdesc:a43ff58bf0e205153ab6ef78cd823fe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a quantum gate to the ZX-diagram  <a href="classSharq_1_1ZXDiagram.html#a43ff58bf0e205153ab6ef78cd823fe89">More...</a><br /></td></tr>
<tr class="separator:a43ff58bf0e205153ab6ef78cd823fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6a94ea7ca7a2a2b990813e093aa2df"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#acf6a94ea7ca7a2a2b990813e093aa2df">append_node</a> (const <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a> node)</td></tr>
<tr class="memdesc:acf6a94ea7ca7a2a2b990813e093aa2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a node of ZX-diagram  <a href="classSharq_1_1ZXDiagram.html#acf6a94ea7ca7a2a2b990813e093aa2df">More...</a><br /></td></tr>
<tr class="separator:acf6a94ea7ca7a2a2b990813e093aa2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5220e5a9805055210cb01279a3ec43f6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a5220e5a9805055210cb01279a3ec43f6">append_node</a> (const <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a> node, const <a class="el" href="classSharq_1_1ZXEdge.html">ZXEdge</a> edge)</td></tr>
<tr class="memdesc:a5220e5a9805055210cb01279a3ec43f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a node and an edge connected to the node  <a href="classSharq_1_1ZXDiagram.html#a5220e5a9805055210cb01279a3ec43f6">More...</a><br /></td></tr>
<tr class="separator:a5220e5a9805055210cb01279a3ec43f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406de188995df74eccad2d598e5dfb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a406de188995df74eccad2d598e5dfb1a">connect_nodes</a> (const uint32_t a, const uint32_t b, const <a class="el" href="zx_8h.html#a3a902e638bb00efe6c25078e5a9c6cf7">ZXEdgeKind</a> <a class="el" href="classSharq_1_1ZXDiagram.html#a96f7c32e4f8a200443585b4406610c15">kind</a>)</td></tr>
<tr class="memdesc:a406de188995df74eccad2d598e5dfb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">make an edge connected two nodes specified the indexes, and assign the kind to the edge  <a href="classSharq_1_1ZXDiagram.html#a406de188995df74eccad2d598e5dfb1a">More...</a><br /></td></tr>
<tr class="separator:a406de188995df74eccad2d598e5dfb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed92e5a307e84b7490f3f6920c410bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a3a902e638bb00efe6c25078e5a9c6cf7">ZXEdgeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a8ed92e5a307e84b7490f3f6920c410bc">remove_edge</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:a8ed92e5a307e84b7490f3f6920c410bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove an edge between two nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#a8ed92e5a307e84b7490f3f6920c410bc">More...</a><br /></td></tr>
<tr class="separator:a8ed92e5a307e84b7490f3f6920c410bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db066c34de34973f8c2dd62d645c668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a2db066c34de34973f8c2dd62d645c668">update_node_places</a> ()</td></tr>
<tr class="memdesc:a2db066c34de34973f8c2dd62d645c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the vector of the node places  <a href="classSharq_1_1ZXDiagram.html#a2db066c34de34973f8c2dd62d645c668">More...</a><br /></td></tr>
<tr class="separator:a2db066c34de34973f8c2dd62d645c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca95419d37fb25920600fbd9623d7bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#aca95419d37fb25920600fbd9623d7bb5">update_phase_gadget</a> ()</td></tr>
<tr class="memdesc:aca95419d37fb25920600fbd9623d7bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the vector of the phase gadget  <a href="classSharq_1_1ZXDiagram.html#aca95419d37fb25920600fbd9623d7bb5">More...</a><br /></td></tr>
<tr class="separator:aca95419d37fb25920600fbd9623d7bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c7cdfefcad30c2a0f51fca53c45e09"><td class="memItemLeft" align="right" valign="top"><a id="a24c7cdfefcad30c2a0f51fca53c45e09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a24c7cdfefcad30c2a0f51fca53c45e09">graph_like</a> ()</td></tr>
<tr class="memdesc:a24c7cdfefcad30c2a0f51fca53c45e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the ZX-diagram to the graph-like ZX-diagram <br /></td></tr>
<tr class="separator:a24c7cdfefcad30c2a0f51fca53c45e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa560f1bfebf5489be5979b1609f662ba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#aa560f1bfebf5489be5979b1609f662ba">lcomp</a> ()</td></tr>
<tr class="memdesc:aa560f1bfebf5489be5979b1609f662ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a local complimmentation algorithm  <a href="classSharq_1_1ZXDiagram.html#aa560f1bfebf5489be5979b1609f662ba">More...</a><br /></td></tr>
<tr class="separator:aa560f1bfebf5489be5979b1609f662ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51d1df97a8db36842032ac213991598"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae51d1df97a8db36842032ac213991598">pivot1</a> ()</td></tr>
<tr class="memdesc:ae51d1df97a8db36842032ac213991598"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot1 algorithm  <a href="classSharq_1_1ZXDiagram.html#ae51d1df97a8db36842032ac213991598">More...</a><br /></td></tr>
<tr class="separator:ae51d1df97a8db36842032ac213991598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea45bdd1ae7d2e9cf8ff849b10336e3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#acea45bdd1ae7d2e9cf8ff849b10336e3">pivot2</a> ()</td></tr>
<tr class="memdesc:acea45bdd1ae7d2e9cf8ff849b10336e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot2 algorithm  <a href="classSharq_1_1ZXDiagram.html#acea45bdd1ae7d2e9cf8ff849b10336e3">More...</a><br /></td></tr>
<tr class="separator:acea45bdd1ae7d2e9cf8ff849b10336e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb9f8390a9d41f403ebc81b27408ec3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a2cb9f8390a9d41f403ebc81b27408ec3">pivot3</a> ()</td></tr>
<tr class="memdesc:a2cb9f8390a9d41f403ebc81b27408ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot3 algorithm  <a href="classSharq_1_1ZXDiagram.html#a2cb9f8390a9d41f403ebc81b27408ec3">More...</a><br /></td></tr>
<tr class="separator:a2cb9f8390a9d41f403ebc81b27408ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d4b9fc8e2de5ab9885c374dc122295"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a55d4b9fc8e2de5ab9885c374dc122295">gfusion</a> ()</td></tr>
<tr class="memdesc:a55d4b9fc8e2de5ab9885c374dc122295"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a gadget fusion algorithm  <a href="classSharq_1_1ZXDiagram.html#a55d4b9fc8e2de5ab9885c374dc122295">More...</a><br /></td></tr>
<tr class="separator:a55d4b9fc8e2de5ab9885c374dc122295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad6db5d6bc50381569baf921501f5e5"><td class="memItemLeft" align="right" valign="top"><a id="a8ad6db5d6bc50381569baf921501f5e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a8ad6db5d6bc50381569baf921501f5e5">id_removal</a> ()</td></tr>
<tr class="memdesc:a8ad6db5d6bc50381569baf921501f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all identity spiders <br /></td></tr>
<tr class="separator:a8ad6db5d6bc50381569baf921501f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33a453178d582f24138be840a622da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#af33a453178d582f24138be840a622da4">simplify</a> ()</td></tr>
<tr class="memdesc:af33a453178d582f24138be840a622da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplify the ZX-diagram  <a href="classSharq_1_1ZXDiagram.html#af33a453178d582f24138be840a622da4">More...</a><br /></td></tr>
<tr class="separator:af33a453178d582f24138be840a622da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d38696c69896f6dfd07820d080d81"><td class="memItemLeft" align="right" valign="top"><a id="adf8d38696c69896f6dfd07820d080d81"></a>
<a class="el" href="classSharq_1_1QCirc.html">QCirc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#adf8d38696c69896f6dfd07820d080d81">extract_qcirc</a> ()</td></tr>
<tr class="memdesc:adf8d38696c69896f6dfd07820d080d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a quantum circuit from the graph-like ZX-diagram <br /></td></tr>
<tr class="separator:adf8d38696c69896f6dfd07820d080d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acd3b54fc3e1682a5e65728bcf93ea92e"><td class="memItemLeft" align="right" valign="top"><a id="acd3b54fc3e1682a5e65728bcf93ea92e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#acd3b54fc3e1682a5e65728bcf93ea92e">max_adj_num</a> () const</td></tr>
<tr class="memdesc:acd3b54fc3e1682a5e65728bcf93ea92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a maximum number of the adjacent nodes <br /></td></tr>
<tr class="separator:acd3b54fc3e1682a5e65728bcf93ea92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300cca877170502f310970e8a60e4179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a300cca877170502f310970e8a60e4179">check_x_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a300cca877170502f310970e8a60e4179"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a X spider or not  <a href="classSharq_1_1ZXDiagram.html#a300cca877170502f310970e8a60e4179">More...</a><br /></td></tr>
<tr class="separator:a300cca877170502f310970e8a60e4179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc59218302bd60a93fa1c7189d1696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a66cc59218302bd60a93fa1c7189d1696">check_z_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a66cc59218302bd60a93fa1c7189d1696"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a Z spider or not  <a href="classSharq_1_1ZXDiagram.html#a66cc59218302bd60a93fa1c7189d1696">More...</a><br /></td></tr>
<tr class="separator:a66cc59218302bd60a93fa1c7189d1696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d3315bdac75d388e214093497c1649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a19d3315bdac75d388e214093497c1649">check_zero_phase_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a19d3315bdac75d388e214093497c1649"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a zero phase spider or not  <a href="classSharq_1_1ZXDiagram.html#a19d3315bdac75d388e214093497c1649">More...</a><br /></td></tr>
<tr class="separator:a19d3315bdac75d388e214093497c1649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d0bd73931a702a58f143ac80d9a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ac61d0bd73931a702a58f143ac80d9a62">check_pauli_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ac61d0bd73931a702a58f143ac80d9a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a pauli spider or not  <a href="classSharq_1_1ZXDiagram.html#ac61d0bd73931a702a58f143ac80d9a62">More...</a><br /></td></tr>
<tr class="separator:ac61d0bd73931a702a58f143ac80d9a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b7863b87ada9f2d69e553a0a4672bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab6b7863b87ada9f2d69e553a0a4672bf">check_proper_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ab6b7863b87ada9f2d69e553a0a4672bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a proper clifford spider or not  <a href="classSharq_1_1ZXDiagram.html#ab6b7863b87ada9f2d69e553a0a4672bf">More...</a><br /></td></tr>
<tr class="separator:ab6b7863b87ada9f2d69e553a0a4672bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e5ba5697508c84118c2605c74c97e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ac17e5ba5697508c84118c2605c74c97e">check_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ac17e5ba5697508c84118c2605c74c97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a clifford spider or not  <a href="classSharq_1_1ZXDiagram.html#ac17e5ba5697508c84118c2605c74c97e">More...</a><br /></td></tr>
<tr class="separator:ac17e5ba5697508c84118c2605c74c97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fe89facccad8e9c2ed2aad0e61a373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a94fe89facccad8e9c2ed2aad0e61a373">check_non_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a94fe89facccad8e9c2ed2aad0e61a373"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a non-clifford spider or not  <a href="classSharq_1_1ZXDiagram.html#a94fe89facccad8e9c2ed2aad0e61a373">More...</a><br /></td></tr>
<tr class="separator:a94fe89facccad8e9c2ed2aad0e61a373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d954c206a4dee3adf3f57880cf46475"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a0d954c206a4dee3adf3f57880cf46475">check_internal_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a0d954c206a4dee3adf3f57880cf46475"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a internal node or not  <a href="classSharq_1_1ZXDiagram.html#a0d954c206a4dee3adf3f57880cf46475">More...</a><br /></td></tr>
<tr class="separator:a0d954c206a4dee3adf3f57880cf46475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81121e04268c1894809879cd8332708f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a81121e04268c1894809879cd8332708f">check_boundary_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a81121e04268c1894809879cd8332708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a boundary node or not  <a href="classSharq_1_1ZXDiagram.html#a81121e04268c1894809879cd8332708f">More...</a><br /></td></tr>
<tr class="separator:a81121e04268c1894809879cd8332708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0a7498edf2aed4c2fb0727cafe8221"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a2b0a7498edf2aed4c2fb0727cafe8221">check_pg_phase_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a2b0a7498edf2aed4c2fb0727cafe8221"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a phase node of a phase gadget or not  <a href="classSharq_1_1ZXDiagram.html#a2b0a7498edf2aed4c2fb0727cafe8221">More...</a><br /></td></tr>
<tr class="separator:a2b0a7498edf2aed4c2fb0727cafe8221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f48fd4620d88b636a2e70044ee388ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a7f48fd4620d88b636a2e70044ee388ad">check_pg_root_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a7f48fd4620d88b636a2e70044ee388ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a root node of a phase gadget or not  <a href="classSharq_1_1ZXDiagram.html#a7f48fd4620d88b636a2e70044ee388ad">More...</a><br /></td></tr>
<tr class="separator:a7f48fd4620d88b636a2e70044ee388ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e66d2478c652d9e6ef23702e51f338"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a75e66d2478c652d9e6ef23702e51f338">check_pg_leaf_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a75e66d2478c652d9e6ef23702e51f338"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a leaf node of a phase gadget or not  <a href="classSharq_1_1ZXDiagram.html#a75e66d2478c652d9e6ef23702e51f338">More...</a><br /></td></tr>
<tr class="separator:a75e66d2478c652d9e6ef23702e51f338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63017da3701baf1342cf79b24c24cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#af63017da3701baf1342cf79b24c24cf9">check_phase_gadget_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:af63017da3701baf1342cf79b24c24cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a node of a phase gadget (phase or root) or not  <a href="classSharq_1_1ZXDiagram.html#af63017da3701baf1342cf79b24c24cf9">More...</a><br /></td></tr>
<tr class="separator:af63017da3701baf1342cf79b24c24cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96e10366a15f9b16cc5718699add710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ad96e10366a15f9b16cc5718699add710">check_input_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ad96e10366a15f9b16cc5718699add710"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a input node or not  <a href="classSharq_1_1ZXDiagram.html#ad96e10366a15f9b16cc5718699add710">More...</a><br /></td></tr>
<tr class="separator:ad96e10366a15f9b16cc5718699add710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ade042b6676cd092e4aef4cbdc4971"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a71ade042b6676cd092e4aef4cbdc4971">check_output_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a71ade042b6676cd092e4aef4cbdc4971"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a output node or not  <a href="classSharq_1_1ZXDiagram.html#a71ade042b6676cd092e4aef4cbdc4971">More...</a><br /></td></tr>
<tr class="separator:a71ade042b6676cd092e4aef4cbdc4971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ab4a2843cc95a5414c7cedda6b62e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a550ab4a2843cc95a5414c7cedda6b62e">check_connect_input_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a550ab4a2843cc95a5414c7cedda6b62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a input node or not  <a href="classSharq_1_1ZXDiagram.html#a550ab4a2843cc95a5414c7cedda6b62e">More...</a><br /></td></tr>
<tr class="separator:a550ab4a2843cc95a5414c7cedda6b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae635b7214bb957ccdbb04065fdd3274c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae635b7214bb957ccdbb04065fdd3274c">check_connect_output_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:ae635b7214bb957ccdbb04065fdd3274c"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a output node or not  <a href="classSharq_1_1ZXDiagram.html#ae635b7214bb957ccdbb04065fdd3274c">More...</a><br /></td></tr>
<tr class="separator:ae635b7214bb957ccdbb04065fdd3274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2efebe7712e0345563fcc3a514df9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a9f2efebe7712e0345563fcc3a514df9f">check_connect_phase_gadget</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a9f2efebe7712e0345563fcc3a514df9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a phase gadget (phase or root) or not  <a href="classSharq_1_1ZXDiagram.html#a9f2efebe7712e0345563fcc3a514df9f">More...</a><br /></td></tr>
<tr class="separator:a9f2efebe7712e0345563fcc3a514df9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a479ad821c40d0d4cafde72ac3ce8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab5a479ad821c40d0d4cafde72ac3ce8e">check_connect</a> (const uint32_t a, const uint32_t b) const</td></tr>
<tr class="memdesc:ab5a479ad821c40d0d4cafde72ac3ce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the two nodes specified in these indexes are connected or not  <a href="classSharq_1_1ZXDiagram.html#ab5a479ad821c40d0d4cafde72ac3ce8e">More...</a><br /></td></tr>
<tr class="separator:ab5a479ad821c40d0d4cafde72ac3ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad598119e9dfc01f2c67136f6816994f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#aad598119e9dfc01f2c67136f6816994f">xor_hadamard_edge</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:aad598119e9dfc01f2c67136f6816994f"><td class="mdescLeft">&#160;</td><td class="mdescRight">operate XOR by the hadamard edge between two nodes specified in these indexes  <a href="classSharq_1_1ZXDiagram.html#aad598119e9dfc01f2c67136f6816994f">More...</a><br /></td></tr>
<tr class="separator:aad598119e9dfc01f2c67136f6816994f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1e653e6b11a31a842812adb00146e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a3c1e653e6b11a31a842812adb00146e7">xor_hadamard_edges</a> (std::vector&lt; uint32_t &gt; node_indexes)</td></tr>
<tr class="memdesc:a3c1e653e6b11a31a842812adb00146e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">operate XOR by the all hadamard edges composed by any pair of two nodes  <a href="classSharq_1_1ZXDiagram.html#a3c1e653e6b11a31a842812adb00146e7">More...</a><br /></td></tr>
<tr class="separator:a3c1e653e6b11a31a842812adb00146e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0815dc9c96a4e2f2c5f853d99c317559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a02d92af0ad71fc8475cc293d5406577f">ZXNodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a0815dc9c96a4e2f2c5f853d99c317559">remove_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a0815dc9c96a4e2f2c5f853d99c317559"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a node specified in the index  <a href="classSharq_1_1ZXDiagram.html#a0815dc9c96a4e2f2c5f853d99c317559">More...</a><br /></td></tr>
<tr class="separator:a0815dc9c96a4e2f2c5f853d99c317559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b3df0d7b189fa0ff8e7a8a74a8c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#af78b3df0d7b189fa0ff8e7a8a74a8c93">remove_edges_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:af78b3df0d7b189fa0ff8e7a8a74a8c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all edges connected to the node specified in the index  <a href="classSharq_1_1ZXDiagram.html#af78b3df0d7b189fa0ff8e7a8a74a8c93">More...</a><br /></td></tr>
<tr class="separator:af78b3df0d7b189fa0ff8e7a8a74a8c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae885fe4a203f4a09c00181bce24b61bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae885fe4a203f4a09c00181bce24b61bb">degree_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:ae885fe4a203f4a09c00181bce24b61bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a degree of the node specified in the index  <a href="classSharq_1_1ZXDiagram.html#ae885fe4a203f4a09c00181bce24b61bb">More...</a><br /></td></tr>
<tr class="separator:ae885fe4a203f4a09c00181bce24b61bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0171d6fdd247879e97c0ea977682ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a02d92af0ad71fc8475cc293d5406577f">ZXNodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a6f0171d6fdd247879e97c0ea977682ff">kind_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a6f0171d6fdd247879e97c0ea977682ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a kind of the node specified in the index  <a href="classSharq_1_1ZXDiagram.html#a6f0171d6fdd247879e97c0ea977682ff">More...</a><br /></td></tr>
<tr class="separator:a6f0171d6fdd247879e97c0ea977682ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8fd797cd0fe9daeee1cb1898b31034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a4b8fd797cd0fe9daeee1cb1898b31034">swap_nodes</a> (uint32_t i, uint32_t j)</td></tr>
<tr class="memdesc:a4b8fd797cd0fe9daeee1cb1898b31034"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#a4b8fd797cd0fe9daeee1cb1898b31034">More...</a><br /></td></tr>
<tr class="separator:a4b8fd797cd0fe9daeee1cb1898b31034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae34b8fc1612fcda76d777a40ecfc8d"><td class="memItemLeft" align="right" valign="top"><a id="adae34b8fc1612fcda76d777a40ecfc8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#adae34b8fc1612fcda76d777a40ecfc8d">remove_isolated_spiders</a> ()</td></tr>
<tr class="memdesc:adae34b8fc1612fcda76d777a40ecfc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove isolated spiders <br /></td></tr>
<tr class="separator:adae34b8fc1612fcda76d777a40ecfc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce1eb27e0a0f600572fe76c2b972de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a29ce1eb27e0a0f600572fe76c2b972de">row_operation</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:a29ce1eb27e0a0f600572fe76c2b972de"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute row operation for the two nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#a29ce1eb27e0a0f600572fe76c2b972de">More...</a><br /></td></tr>
<tr class="separator:a29ce1eb27e0a0f600572fe76c2b972de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6551eec6379336737cf40c5bdc1c811"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ad6551eec6379336737cf40c5bdc1c811">adjacent_node_indexes</a> (uint32_t node_index)</td></tr>
<tr class="memdesc:ad6551eec6379336737cf40c5bdc1c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of nodes adjacent to the node specified in the index  <a href="classSharq_1_1ZXDiagram.html#ad6551eec6379336737cf40c5bdc1c811">More...</a><br /></td></tr>
<tr class="separator:ad6551eec6379336737cf40c5bdc1c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0072b9b65dc20d60e141e273801ea6"><td class="memItemLeft" align="right" valign="top"><a id="a3b0072b9b65dc20d60e141e273801ea6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a3b0072b9b65dc20d60e141e273801ea6">conv_x_to_z</a> ()</td></tr>
<tr class="memdesc:a3b0072b9b65dc20d60e141e273801ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert all X spiders to Z spiders with hadamard edges <br /></td></tr>
<tr class="separator:a3b0072b9b65dc20d60e141e273801ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f8904332828503621b3697a4ef6c2"><td class="memItemLeft" align="right" valign="top"><a id="ab15f8904332828503621b3697a4ef6c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab15f8904332828503621b3697a4ef6c2">fuse_spiders</a> ()</td></tr>
<tr class="memdesc:ab15f8904332828503621b3697a4ef6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuse all spiders <br /></td></tr>
<tr class="separator:ab15f8904332828503621b3697a4ef6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc2d62ea4f545134612cb30b41e9a13"><td class="memItemLeft" align="right" valign="top"><a id="a2dc2d62ea4f545134612cb30b41e9a13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a2dc2d62ea4f545134612cb30b41e9a13">remove_parallel_selfloops_hadamard_edges</a> ()</td></tr>
<tr class="memdesc:a2dc2d62ea4f545134612cb30b41e9a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all parallel hadamard edges and self-looped hadamard edges <br /></td></tr>
<tr class="separator:a2dc2d62ea4f545134612cb30b41e9a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48df3d75ae2205fc63d5cb42e28183c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ad48df3d75ae2205fc63d5cb42e28183c">permutation_as_swap</a> (<a class="el" href="classSharq_1_1QCirc.html">QCirc</a> &amp;qc)</td></tr>
<tr class="memdesc:ad48df3d75ae2205fc63d5cb42e28183c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add swap gates to reorder the swapped qubit indexes to the original order in process of extracting the quantum circuit  <a href="classSharq_1_1ZXDiagram.html#ad48df3d75ae2205fc63d5cb42e28183c">More...</a><br /></td></tr>
<tr class="separator:ad48df3d75ae2205fc63d5cb42e28183c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d5ae9394f880c3715fbb0ddf08d065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a90d5ae9394f880c3715fbb0ddf08d065">process_frontier</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;qc, const bool opt_cz=false)</td></tr>
<tr class="memdesc:a90d5ae9394f880c3715fbb0ddf08d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the frontier spiders initially  <a href="classSharq_1_1ZXDiagram.html#a90d5ae9394f880c3715fbb0ddf08d065">More...</a><br /></td></tr>
<tr class="separator:a90d5ae9394f880c3715fbb0ddf08d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68e621a38d81d69e049f48eca7fca4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ae68e621a38d81d69e049f48eca7fca4c">update_frontier</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;qc, const bool opt_cz=false)</td></tr>
<tr class="memdesc:ae68e621a38d81d69e049f48eca7fca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract quantum gates from the ZX-diagram and update the frontier spiders  <a href="classSharq_1_1ZXDiagram.html#ae68e621a38d81d69e049f48eca7fca4c">More...</a><br /></td></tr>
<tr class="separator:ae68e621a38d81d69e049f48eca7fca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb7d6338fb7acccb868d4d67998ccbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a8eb7d6338fb7acccb868d4d67998ccbf">update_frontier_pg</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;qc)</td></tr>
<tr class="memdesc:a8eb7d6338fb7acccb868d4d67998ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">update frontier spiders in the case that the frontier can't be updated because of invalid biadjacency matrix related to the frontier  <a href="classSharq_1_1ZXDiagram.html#a8eb7d6338fb7acccb868d4d67998ccbf">More...</a><br /></td></tr>
<tr class="separator:a8eb7d6338fb7acccb868d4d67998ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73ee743528df8b191e5f6d3b25168cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#af73ee743528df8b191e5f6d3b25168cd">lcomp_one_time</a> (const uint32_t idx_A)</td></tr>
<tr class="memdesc:af73ee743528df8b191e5f6d3b25168cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a local complimmentation algorithm for the node specified in the index  <a href="classSharq_1_1ZXDiagram.html#af73ee743528df8b191e5f6d3b25168cd">More...</a><br /></td></tr>
<tr class="separator:af73ee743528df8b191e5f6d3b25168cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783ff5c6da4185904b041db8e613e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab783ff5c6da4185904b041db8e613e36">pivot1_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:ab783ff5c6da4185904b041db8e613e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot1 algorithm for the nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#ab783ff5c6da4185904b041db8e613e36">More...</a><br /></td></tr>
<tr class="separator:ab783ff5c6da4185904b041db8e613e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5360937135157e177a20e36d584ebeb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a5360937135157e177a20e36d584ebeb3">pivot2_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:a5360937135157e177a20e36d584ebeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot2 algorithm for the nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#a5360937135157e177a20e36d584ebeb3">More...</a><br /></td></tr>
<tr class="separator:a5360937135157e177a20e36d584ebeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98379a84de4bb84e6070611de94e4394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a98379a84de4bb84e6070611de94e4394">pivot3_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:a98379a84de4bb84e6070611de94e4394"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot3 algorithm for the nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#a98379a84de4bb84e6070611de94e4394">More...</a><br /></td></tr>
<tr class="separator:a98379a84de4bb84e6070611de94e4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11b062cfa7517a8d940304ae50e6d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab11b062cfa7517a8d940304ae50e6d1c">gfusion_one_time</a> (const uint32_t idx_A_phase, const uint32_t idx_B_phase)</td></tr>
<tr class="memdesc:ab11b062cfa7517a8d940304ae50e6d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a gadget fusion algorithm for the nodes specified in the indexes  <a href="classSharq_1_1ZXDiagram.html#ab11b062cfa7517a8d940304ae50e6d1c">More...</a><br /></td></tr>
<tr class="separator:ab11b062cfa7517a8d940304ae50e6d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada677a14e4c3cdfa9dda9495a2db7811"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ada677a14e4c3cdfa9dda9495a2db7811">extract_2q_connects</a> (std::vector&lt; uint32_t &gt; &amp;frontier) const</td></tr>
<tr class="memdesc:ada677a14e4c3cdfa9dda9495a2db7811"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract 2Q connections from the frontier (for CZ optimization in the update_frontier function)  <a href="classSharq_1_1ZXDiagram.html#ada677a14e4c3cdfa9dda9495a2db7811">More...</a><br /></td></tr>
<tr class="separator:ada677a14e4c3cdfa9dda9495a2db7811"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a82bb6ca1e900c67b9a4a7e67b0e07334"><td class="memItemLeft" align="right" valign="top"><a id="a82bb6ca1e900c67b9a4a7e67b0e07334"></a>
<a class="el" href="zx_8h.html#aebf0fc24b275ec10e880ea29554b16cc">ZXDiagramKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a82bb6ca1e900c67b9a4a7e67b0e07334">kind_</a></td></tr>
<tr class="memdesc:a82bb6ca1e900c67b9a4a7e67b0e07334"><td class="mdescLeft">&#160;</td><td class="mdescRight">kind of the ZX-diagram <br /></td></tr>
<tr class="separator:a82bb6ca1e900c67b9a4a7e67b0e07334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dba1de2674d750fa763a24b4322f698"><td class="memItemLeft" align="right" valign="top"><a id="a8dba1de2674d750fa763a24b4322f698"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a8dba1de2674d750fa763a24b4322f698">qubit_num_</a></td></tr>
<tr class="memdesc:a8dba1de2674d750fa763a24b4322f698"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of qubits <br /></td></tr>
<tr class="separator:a8dba1de2674d750fa763a24b4322f698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e159702a5fa2232abd3f88c89a52c5e"><td class="memItemLeft" align="right" valign="top"><a id="a3e159702a5fa2232abd3f88c89a52c5e"></a>
std::vector&lt; <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a3e159702a5fa2232abd3f88c89a52c5e">nodes_</a></td></tr>
<tr class="memdesc:a3e159702a5fa2232abd3f88c89a52c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the <a class="el" href="classSharq_1_1ZXNode.html" title="node of ZX-diagram">ZXNode</a> objects <br /></td></tr>
<tr class="separator:a3e159702a5fa2232abd3f88c89a52c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d6a5ffd4b7dfdd7fd24dfd7589a606"><td class="memItemLeft" align="right" valign="top"><a id="a26d6a5ffd4b7dfdd7fd24dfd7589a606"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a26d6a5ffd4b7dfdd7fd24dfd7589a606">inputs_</a></td></tr>
<tr class="memdesc:a26d6a5ffd4b7dfdd7fd24dfd7589a606"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the input node indexes <br /></td></tr>
<tr class="separator:a26d6a5ffd4b7dfdd7fd24dfd7589a606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3aabaac1888272cae3983e67e241c1d"><td class="memItemLeft" align="right" valign="top"><a id="ab3aabaac1888272cae3983e67e241c1d"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ab3aabaac1888272cae3983e67e241c1d">outputs_</a></td></tr>
<tr class="memdesc:ab3aabaac1888272cae3983e67e241c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the output node indexes <br /></td></tr>
<tr class="separator:ab3aabaac1888272cae3983e67e241c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad516c1a14e03ec9faf3a3b50a36c1498"><td class="memItemLeft" align="right" valign="top"><a id="ad516c1a14e03ec9faf3a3b50a36c1498"></a>
std::vector&lt; std::vector&lt; <a class="el" href="classSharq_1_1ZXEdge.html">ZXEdge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#ad516c1a14e03ec9faf3a3b50a36c1498">adj_mat_</a></td></tr>
<tr class="memdesc:ad516c1a14e03ec9faf3a3b50a36c1498"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacent matrix of the ZX-diagram <br /></td></tr>
<tr class="separator:ad516c1a14e03ec9faf3a3b50a36c1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90162ce03882022e23023fe699ecae1d"><td class="memItemLeft" align="right" valign="top"><a id="a90162ce03882022e23023fe699ecae1d"></a>
std::vector&lt; <a class="el" href="zx_8h.html#ae10c265d12d7b287d16f07f53be074b8">ZXNodePlace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharq_1_1ZXDiagram.html#a90162ce03882022e23023fe699ecae1d">node_places_</a></td></tr>
<tr class="memdesc:a90162ce03882022e23023fe699ecae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the node places (Terminal, Boundary or Internal) <br /></td></tr>
<tr class="separator:a90162ce03882022e23023fe699ecae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af6bdef1f0bca5036a8df8f8e801ac541"><td class="memItemLeft" align="right" valign="top"><a id="af6bdef1f0bca5036a8df8f8e801ac541"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;ost, const <a class="el" href="classSharq_1_1ZXDiagram.html">ZXDiagram</a> &amp;zx)</td></tr>
<tr class="separator:af6bdef1f0bca5036a8df8f8e801ac541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ZX-diagram. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXNode.html" title="node of ZX-diagram">ZXNode</a> </dd>
<dd>
<a class="el" href="classSharq_1_1ZXEdge.html" title="edge of ZX-diagram">ZXEdge</a> </dd>
<dd>
1. Ross Duncan, Aleks Kissinger, Simon Perdrix, John van de Wetering, "Graph-theoretic Simplification of Quantum Circuits with the ZX-calculus", <a href="https://arxiv.org/abs/1902.03178">arXiv:1902.03178</a> </dd>
<dd>
2. Aleks Kissinger, John van de Wetering, "Reducing T-count with the ZX-calculus", <a href="https://arxiv.org/abs/1903.10477">arXiv:1903.10477</a> </dd>
<dd>
3. Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski, John van de Wetering, "There and back again: A circuit extraction tale", <a href="https://arxiv.org/abs/2003.01664">arXiv:2003.01664</a> </dd>
<dd>
4. Korbinian Staudacher, "Optimization Approaches for Quantum Circuits using ZX-calculus" <a href="https://www.mnm-team.org/pub/Diplomarbeiten/stau21/PDF-Version/stau21.pdf">Ludwig maximilian university of munich thesis</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a469c13bb8ac50c50a279cc35f419da3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469c13bb8ac50c50a279cc35f419da3a">&#9670;&nbsp;</a></span>ZXDiagram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sharq::ZXDiagram::ZXDiagram </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>qubit_num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qubit_num</td><td>number of qubits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ec429e9860b3ff29683451df003cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ec429e9860b3ff29683451df003cb7">&#9670;&nbsp;</a></span>ZXDiagram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sharq::ZXDiagram::ZXDiagram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharq_1_1ZXDiagram.html">ZXDiagram</a> &amp;&#160;</td>
          <td class="paramname"><em>zx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zx</td><td><a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a43ff58bf0e205153ab6ef78cd823fe89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ff58bf0e205153ab6ef78cd823fe89">&#9670;&nbsp;</a></span>add_qgate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::add_qgate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharq_1_1QGate.html">QGate</a> &amp;&#160;</td>
          <td class="paramname"><em>qgate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a quantum gate to the ZX-diagram </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qgate</td><td>quantum gate added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6551eec6379336737cf40c5bdc1c811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6551eec6379336737cf40c5bdc1c811">&#9670;&nbsp;</a></span>adjacent_node_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; Sharq::ZXDiagram::adjacent_node_indexes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a vector of nodes adjacent to the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of nodes adjacent to the node specified in the index </dd></dl>

</div>
</div>
<a id="acf6a94ea7ca7a2a2b990813e093aa2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6a94ea7ca7a2a2b990813e093aa2df">&#9670;&nbsp;</a></span>append_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::append_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append a node of ZX-diagram </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>node of ZX-diagram </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5220e5a9805055210cb01279a3ec43f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5220e5a9805055210cb01279a3ec43f6">&#9670;&nbsp;</a></span>append_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::append_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharq_1_1ZXNode.html">ZXNode</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSharq_1_1ZXEdge.html">ZXEdge</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append a node and an edge connected to the node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>node of ZX-diagram </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>edge of ZX-diagram </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81121e04268c1894809879cd8332708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81121e04268c1894809879cd8332708f">&#9670;&nbsp;</a></span>check_boundary_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_boundary_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a boundary node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a boundary node, false otherwise </dd></dl>

</div>
</div>
<a id="ac17e5ba5697508c84118c2605c74c97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17e5ba5697508c84118c2605c74c97e">&#9670;&nbsp;</a></span>check_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="ab5a479ad821c40d0d4cafde72ac3ce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a479ad821c40d0d4cafde72ac3ce8e">&#9670;&nbsp;</a></span>check_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_connect </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the two nodes specified in these indexes are connected or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two nodes specified in these indexes are connected, false otherwise </dd></dl>

</div>
</div>
<a id="a550ab4a2843cc95a5414c7cedda6b62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ab4a2843cc95a5414c7cedda6b62e">&#9670;&nbsp;</a></span>check_connect_input_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_connect_input_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a input node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a input node, false otherwise </dd></dl>

</div>
</div>
<a id="ae635b7214bb957ccdbb04065fdd3274c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae635b7214bb957ccdbb04065fdd3274c">&#9670;&nbsp;</a></span>check_connect_output_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_connect_output_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a output node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a output node, false otherwise </dd></dl>

</div>
</div>
<a id="a9f2efebe7712e0345563fcc3a514df9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2efebe7712e0345563fcc3a514df9f">&#9670;&nbsp;</a></span>check_connect_phase_gadget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_connect_phase_gadget </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a phase gadget (phase or root) or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a phase gadget (phase or root), false otherwise </dd></dl>

</div>
</div>
<a id="ad96e10366a15f9b16cc5718699add710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96e10366a15f9b16cc5718699add710">&#9670;&nbsp;</a></span>check_input_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_input_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a input node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a input node, false otherwise </dd></dl>

</div>
</div>
<a id="a0d954c206a4dee3adf3f57880cf46475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d954c206a4dee3adf3f57880cf46475">&#9670;&nbsp;</a></span>check_internal_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_internal_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a internal node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a internal node, false otherwise </dd></dl>

</div>
</div>
<a id="a94fe89facccad8e9c2ed2aad0e61a373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fe89facccad8e9c2ed2aad0e61a373">&#9670;&nbsp;</a></span>check_non_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_non_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a non-clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a non-clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="a71ade042b6676cd092e4aef4cbdc4971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ade042b6676cd092e4aef4cbdc4971">&#9670;&nbsp;</a></span>check_output_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_output_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a output node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a output node, false otherwise </dd></dl>

</div>
</div>
<a id="ac61d0bd73931a702a58f143ac80d9a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61d0bd73931a702a58f143ac80d9a62">&#9670;&nbsp;</a></span>check_pauli_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_pauli_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a pauli spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a pauli spider, false otherwise </dd></dl>

</div>
</div>
<a id="a75e66d2478c652d9e6ef23702e51f338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e66d2478c652d9e6ef23702e51f338">&#9670;&nbsp;</a></span>check_pg_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_pg_leaf_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a leaf node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a leaf node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="a2b0a7498edf2aed4c2fb0727cafe8221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0a7498edf2aed4c2fb0727cafe8221">&#9670;&nbsp;</a></span>check_pg_phase_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_pg_phase_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a phase node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a phase node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="a7f48fd4620d88b636a2e70044ee388ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f48fd4620d88b636a2e70044ee388ad">&#9670;&nbsp;</a></span>check_pg_root_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_pg_root_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a root node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a root node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="af63017da3701baf1342cf79b24c24cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63017da3701baf1342cf79b24c24cf9">&#9670;&nbsp;</a></span>check_phase_gadget_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_phase_gadget_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a node of a phase gadget (phase or root) or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a node of a phase gadget (phase or root), false otherwise </dd></dl>

</div>
</div>
<a id="ab6b7863b87ada9f2d69e553a0a4672bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b7863b87ada9f2d69e553a0a4672bf">&#9670;&nbsp;</a></span>check_proper_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_proper_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a proper clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a proper clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="a300cca877170502f310970e8a60e4179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300cca877170502f310970e8a60e4179">&#9670;&nbsp;</a></span>check_x_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_x_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a X spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a X spider, false otherwise </dd></dl>

</div>
</div>
<a id="a66cc59218302bd60a93fa1c7189d1696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc59218302bd60a93fa1c7189d1696">&#9670;&nbsp;</a></span>check_z_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_z_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a Z spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a Z spider, false otherwise </dd></dl>

</div>
</div>
<a id="a19d3315bdac75d388e214093497c1649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d3315bdac75d388e214093497c1649">&#9670;&nbsp;</a></span>check_zero_phase_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::check_zero_phase_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a zero phase spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a zero phase spider, false otherwise </dd></dl>

</div>
</div>
<a id="a406de188995df74eccad2d598e5dfb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406de188995df74eccad2d598e5dfb1a">&#9670;&nbsp;</a></span>connect_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::connect_nodes </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="zx_8h.html#a3a902e638bb00efe6c25078e5a9c6cf7">ZXEdgeKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make an edge connected two nodes specified the indexes, and assign the kind to the edge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>kind of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae885fe4a203f4a09c00181bce24b61bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae885fe4a203f4a09c00181bce24b61bb">&#9670;&nbsp;</a></span>degree_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::degree_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a degree of the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>degree of the node </dd></dl>

</div>
</div>
<a id="ada677a14e4c3cdfa9dda9495a2db7811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada677a14e4c3cdfa9dda9495a2db7811">&#9670;&nbsp;</a></span>extract_2q_connects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;uint32_t, uint32_t&gt; &gt; Sharq::ZXDiagram::extract_2q_connects </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract 2Q connections from the frontier (for CZ optimization in the update_frontier function) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of pairs of the indexes </dd></dl>

</div>
</div>
<a id="a55d4b9fc8e2de5ab9885c374dc122295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d4b9fc8e2de5ab9885c374dc122295">&#9670;&nbsp;</a></span>gfusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::gfusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a gadget fusion algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#ab11b062cfa7517a8d940304ae50e6d1c" title="apply a gadget fusion algorithm for the nodes specified in the indexes">ZXDiagram::gfusion_one_time</a> </dd></dl>

</div>
</div>
<a id="ab11b062cfa7517a8d940304ae50e6d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11b062cfa7517a8d940304ae50e6d1c">&#9670;&nbsp;</a></span>gfusion_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::gfusion_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a gadget fusion algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A_phase</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B_phase</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a55d4b9fc8e2de5ab9885c374dc122295" title="apply a gadget fusion algorithm">ZXDiagram::gfusion</a> </dd></dl>

</div>
</div>
<a id="a6f0171d6fdd247879e97c0ea977682ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0171d6fdd247879e97c0ea977682ff">&#9670;&nbsp;</a></span>kind_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a02d92af0ad71fc8475cc293d5406577f">ZXNodeKind</a> Sharq::ZXDiagram::kind_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a kind of the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the node </dd></dl>

</div>
</div>
<a id="aa560f1bfebf5489be5979b1609f662ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa560f1bfebf5489be5979b1609f662ba">&#9670;&nbsp;</a></span>lcomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::lcomp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a local complimmentation algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#af73ee743528df8b191e5f6d3b25168cd" title="apply a local complimmentation algorithm for the node specified in the index">ZXDiagram::lcomp_one_time</a> </dd></dl>

</div>
</div>
<a id="af73ee743528df8b191e5f6d3b25168cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73ee743528df8b191e5f6d3b25168cd">&#9670;&nbsp;</a></span>lcomp_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::lcomp_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a local complimmentation algorithm for the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#aa560f1bfebf5489be5979b1609f662ba" title="apply a local complimmentation algorithm">ZXDiagram::lcomp</a> </dd></dl>

</div>
</div>
<a id="ad48df3d75ae2205fc63d5cb42e28183c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48df3d75ae2205fc63d5cb42e28183c">&#9670;&nbsp;</a></span>permutation_as_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::permutation_as_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSharq_1_1QCirc.html">QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add swap gates to reorder the swapped qubit indexes to the original order in process of extracting the quantum circuit </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qc</td><td>the quantum circuit that qubit indexes is swapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae51d1df97a8db36842032ac213991598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51d1df97a8db36842032ac213991598">&#9670;&nbsp;</a></span>pivot1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::pivot1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot1 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#ab783ff5c6da4185904b041db8e613e36" title="apply a pivot1 algorithm for the nodes specified in the indexes">ZXDiagram::pivot1_one_time</a> </dd></dl>

</div>
</div>
<a id="ab783ff5c6da4185904b041db8e613e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab783ff5c6da4185904b041db8e613e36">&#9670;&nbsp;</a></span>pivot1_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::pivot1_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot1 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#ae51d1df97a8db36842032ac213991598" title="apply a pivot1 algorithm">ZXDiagram::pivot1</a> </dd></dl>

</div>
</div>
<a id="acea45bdd1ae7d2e9cf8ff849b10336e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea45bdd1ae7d2e9cf8ff849b10336e3">&#9670;&nbsp;</a></span>pivot2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::pivot2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot2 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a5360937135157e177a20e36d584ebeb3" title="apply a pivot2 algorithm for the nodes specified in the indexes">ZXDiagram::pivot2_one_time</a> </dd></dl>

</div>
</div>
<a id="a5360937135157e177a20e36d584ebeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5360937135157e177a20e36d584ebeb3">&#9670;&nbsp;</a></span>pivot2_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::pivot2_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot2 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#acea45bdd1ae7d2e9cf8ff849b10336e3" title="apply a pivot2 algorithm">ZXDiagram::pivot2</a> </dd></dl>

</div>
</div>
<a id="a2cb9f8390a9d41f403ebc81b27408ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb9f8390a9d41f403ebc81b27408ec3">&#9670;&nbsp;</a></span>pivot3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharq::ZXDiagram::pivot3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot3 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a98379a84de4bb84e6070611de94e4394" title="apply a pivot3 algorithm for the nodes specified in the indexes">ZXDiagram::pivot3_one_time</a> </dd></dl>

</div>
</div>
<a id="a98379a84de4bb84e6070611de94e4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98379a84de4bb84e6070611de94e4394">&#9670;&nbsp;</a></span>pivot3_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::pivot3_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot3 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a2cb9f8390a9d41f403ebc81b27408ec3" title="apply a pivot3 algorithm">ZXDiagram::pivot3</a> </dd></dl>

</div>
</div>
<a id="a90d5ae9394f880c3715fbb0ddf08d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d5ae9394f880c3715fbb0ddf08d065">&#9670;&nbsp;</a></span>process_frontier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::process_frontier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>opt_cz</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update the frontier spiders initially </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt_cz</td><td>optimize CZ or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#ae68e621a38d81d69e049f48eca7fca4c" title="extract quantum gates from the ZX-diagram and update the frontier spiders">ZXDiagram::update_frontier</a> </dd>
<dd>
<a class="el" href="classSharq_1_1ZXDiagram.html#a8eb7d6338fb7acccb868d4d67998ccbf" title="update frontier spiders in the case that the frontier can&#39;t be updated because of invalid biadjacency...">ZXDiagram::update_frontier_pg</a> </dd></dl>

</div>
</div>
<a id="a8ed92e5a307e84b7490f3f6920c410bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed92e5a307e84b7490f3f6920c410bc">&#9670;&nbsp;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a3a902e638bb00efe6c25078e5a9c6cf7">ZXEdgeKind</a> Sharq::ZXDiagram::remove_edge </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove an edge between two nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index to be connected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the edge removed </dd></dl>

</div>
</div>
<a id="af78b3df0d7b189fa0ff8e7a8a74a8c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78b3df0d7b189fa0ff8e7a8a74a8c93">&#9670;&nbsp;</a></span>remove_edges_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::remove_edges_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove all edges connected to the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0815dc9c96a4e2f2c5f853d99c317559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0815dc9c96a4e2f2c5f853d99c317559">&#9670;&nbsp;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a02d92af0ad71fc8475cc293d5406577f">ZXNodeKind</a> Sharq::ZXDiagram::remove_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove a node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the node removed </dd></dl>

</div>
</div>
<a id="a29ce1eb27e0a0f600572fe76c2b972de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ce1eb27e0a0f600572fe76c2b972de">&#9670;&nbsp;</a></span>row_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::row_operation </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute row operation for the two nodes specified in the indexes </p>
<p>from the edges of node(a) to the edges of node(b) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af33a453178d582f24138be840a622da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33a453178d582f24138be840a622da4">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simplify the ZX-diagram </p>
<p>apply the algorithm of local complimentation, pivot1, pivot2, pivot3, and gadget fusion, for graph-like diagram converted the original ZX-diagram </p>

</div>
</div>
<a id="ac417c0aafa5583b0d7c82b03c4a567c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac417c0aafa5583b0d7c82b03c4a567c1">&#9670;&nbsp;</a></span>stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, uint32_t&gt; Sharq::ZXDiagram::stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get stats of the ZX-diagram </p>
<dl class="section return"><dt>Returns</dt><dd>stats of the ZX-diagram </dd></dl>

</div>
</div>
<a id="a4b8fd797cd0fe9daeee1cb1898b31034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8fd797cd0fe9daeee1cb1898b31034">&#9670;&nbsp;</a></span>swap_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap two nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b352d128be42e38e82e5ee2d1dc70aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b352d128be42e38e82e5ee2d1dc70aa">&#9670;&nbsp;</a></span>to_dot_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::to_dot_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save as a dot file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>dot file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7839768c8cea16f8215f598686ff7ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7839768c8cea16f8215f598686ff7ce4">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sharq::ZXDiagram::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string of the <a class="el" href="classSharq_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object </p>
<dl class="section return"><dt>Returns</dt><dd>string of the ZX-diagram </dd></dl>

</div>
</div>
<a id="a8f2e225cc9374d1e1267481e68ed0428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e225cc9374d1e1267481e68ed0428">&#9670;&nbsp;</a></span>to_svg_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::to_svg_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save as a svg file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>svg file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae68e621a38d81d69e049f48eca7fca4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68e621a38d81d69e049f48eca7fca4c">&#9670;&nbsp;</a></span>update_frontier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::update_frontier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>opt_cz</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract quantum gates from the ZX-diagram and update the frontier spiders </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt_cz</td><td>optimize CZ or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a90d5ae9394f880c3715fbb0ddf08d065" title="update the frontier spiders initially">ZXDiagram::process_frontier</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>updated or not </dd></dl>

</div>
</div>
<a id="a8eb7d6338fb7acccb868d4d67998ccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb7d6338fb7acccb868d4d67998ccbf">&#9670;&nbsp;</a></span>update_frontier_pg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharq::ZXDiagram::update_frontier_pg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharq_1_1QCirc.html">Sharq::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update frontier spiders in the case that the frontier can't be updated because of invalid biadjacency matrix related to the frontier </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharq_1_1ZXDiagram.html#a90d5ae9394f880c3715fbb0ddf08d065" title="update the frontier spiders initially">ZXDiagram::process_frontier</a> </dd>
<dd>
<a class="el" href="classSharq_1_1ZXDiagram.html#ae68e621a38d81d69e049f48eca7fca4c" title="extract quantum gates from the ZX-diagram and update the frontier spiders">ZXDiagram::update_frontier</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>updated or not </dd></dl>

</div>
</div>
<a id="a2db066c34de34973f8c2dd62d645c668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db066c34de34973f8c2dd62d645c668">&#9670;&nbsp;</a></span>update_node_places()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::update_node_places </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the vector of the node places </p>
<p>this function is always called after updating the ZX-diagram </p>

</div>
</div>
<a id="aca95419d37fb25920600fbd9623d7bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca95419d37fb25920600fbd9623d7bb5">&#9670;&nbsp;</a></span>update_phase_gadget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::update_phase_gadget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the vector of the phase gadget </p>
<p>this function is always called after updating the ZX-diagram </p>

</div>
</div>
<a id="aad598119e9dfc01f2c67136f6816994f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad598119e9dfc01f2c67136f6816994f">&#9670;&nbsp;</a></span>xor_hadamard_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::xor_hadamard_edge </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operate XOR by the hadamard edge between two nodes specified in these indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1e653e6b11a31a842812adb00146e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1e653e6b11a31a842812adb00146e7">&#9670;&nbsp;</a></span>xor_hadamard_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharq::ZXDiagram::xor_hadamard_edges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>node_indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operate XOR by the all hadamard edges composed by any pair of two nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_indexes</td><td>vector of the node indexes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="zx_8h_source.html">zx.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
