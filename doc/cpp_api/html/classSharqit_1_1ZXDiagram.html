<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sharqit: Sharqit::ZXDiagram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sharqit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Sharqit</b></li><li class="navelem"><a class="el" href="classSharqit_1_1ZXDiagram.html">ZXDiagram</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSharqit_1_1ZXDiagram-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sharqit::ZXDiagram Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ZX-diagram.  
 <a href="classSharqit_1_1ZXDiagram.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="zx_8h_source.html">zx.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a691e1b8b827437500767e39ea6db9adf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a691e1b8b827437500767e39ea6db9adf">ZXDiagram</a> (const uint32_t <a class="el" href="classSharqit_1_1ZXDiagram.html#a4131c99ae9be2c03cf13fa2fbc0123e4">qubit_num</a>=1)</td></tr>
<tr class="memdesc:a691e1b8b827437500767e39ea6db9adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a>  <a href="classSharqit_1_1ZXDiagram.html#a691e1b8b827437500767e39ea6db9adf">More...</a><br /></td></tr>
<tr class="separator:a691e1b8b827437500767e39ea6db9adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae61d61c08cceda949b505515d756e51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aae61d61c08cceda949b505515d756e51">ZXDiagram</a> (const <a class="el" href="classSharqit_1_1ZXDiagram.html">ZXDiagram</a> &amp;zx)</td></tr>
<tr class="memdesc:aae61d61c08cceda949b505515d756e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a>  <a href="classSharqit_1_1ZXDiagram.html#aae61d61c08cceda949b505515d756e51">More...</a><br /></td></tr>
<tr class="separator:aae61d61c08cceda949b505515d756e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af076c0c4841ff6f554dbe2e72ae4f2dd"><td class="memItemLeft" align="right" valign="top"><a id="af076c0c4841ff6f554dbe2e72ae4f2dd"></a>
<a class="el" href="zx_8h.html#a68fd425089a9de35d5479f458f791cdd">ZXDiagramKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#af076c0c4841ff6f554dbe2e72ae4f2dd">kind</a> () const</td></tr>
<tr class="memdesc:af076c0c4841ff6f554dbe2e72ae4f2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the kind_ <br /></td></tr>
<tr class="separator:af076c0c4841ff6f554dbe2e72ae4f2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4131c99ae9be2c03cf13fa2fbc0123e4"><td class="memItemLeft" align="right" valign="top"><a id="a4131c99ae9be2c03cf13fa2fbc0123e4"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a4131c99ae9be2c03cf13fa2fbc0123e4">qubit_num</a> () const</td></tr>
<tr class="memdesc:a4131c99ae9be2c03cf13fa2fbc0123e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the qubit_num_ <br /></td></tr>
<tr class="separator:a4131c99ae9be2c03cf13fa2fbc0123e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62becb131183ddae35d6a2e027c5642"><td class="memItemLeft" align="right" valign="top"><a id="ac62becb131183ddae35d6a2e027c5642"></a>
std::vector&lt; <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ac62becb131183ddae35d6a2e027c5642">nodes</a> () const</td></tr>
<tr class="memdesc:ac62becb131183ddae35d6a2e027c5642"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the nodes_ <br /></td></tr>
<tr class="separator:ac62becb131183ddae35d6a2e027c5642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c41fc16175c16e9edf5ee034b841d0"><td class="memItemLeft" align="right" valign="top"><a id="a21c41fc16175c16e9edf5ee034b841d0"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a21c41fc16175c16e9edf5ee034b841d0">inputs</a> () const</td></tr>
<tr class="memdesc:a21c41fc16175c16e9edf5ee034b841d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the inputs_ <br /></td></tr>
<tr class="separator:a21c41fc16175c16e9edf5ee034b841d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c9a52d7fcc1ec0237766bd74c85f6f"><td class="memItemLeft" align="right" valign="top"><a id="a20c9a52d7fcc1ec0237766bd74c85f6f"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a20c9a52d7fcc1ec0237766bd74c85f6f">outputs</a> () const</td></tr>
<tr class="memdesc:a20c9a52d7fcc1ec0237766bd74c85f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the outputs_ <br /></td></tr>
<tr class="separator:a20c9a52d7fcc1ec0237766bd74c85f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1599f4e3de59080aa5ac31912858bee1"><td class="memItemLeft" align="right" valign="top"><a id="a1599f4e3de59080aa5ac31912858bee1"></a>
std::vector&lt; std::vector&lt; <a class="el" href="classSharqit_1_1ZXEdge.html">ZXEdge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a1599f4e3de59080aa5ac31912858bee1">adj_mat</a> () const</td></tr>
<tr class="memdesc:a1599f4e3de59080aa5ac31912858bee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter of the adj_mat_ <br /></td></tr>
<tr class="separator:a1599f4e3de59080aa5ac31912858bee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995b1c4322a0d53653578e55643787ae"><td class="memItemLeft" align="right" valign="top"><a id="a995b1c4322a0d53653578e55643787ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a995b1c4322a0d53653578e55643787ae">kind</a> (const <a class="el" href="zx_8h.html#a68fd425089a9de35d5479f458f791cdd">ZXDiagramKind</a> kind)</td></tr>
<tr class="memdesc:a995b1c4322a0d53653578e55643787ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the kind_ <br /></td></tr>
<tr class="separator:a995b1c4322a0d53653578e55643787ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da6c91ee8bf5077b69d25081f169138"><td class="memItemLeft" align="right" valign="top"><a id="a7da6c91ee8bf5077b69d25081f169138"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a7da6c91ee8bf5077b69d25081f169138">qubit_num</a> (const uint32_t qubit_num)</td></tr>
<tr class="memdesc:a7da6c91ee8bf5077b69d25081f169138"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the qubit_num_ <br /></td></tr>
<tr class="separator:a7da6c91ee8bf5077b69d25081f169138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007dfd9ff62ed582860b7867e80d4f30"><td class="memItemLeft" align="right" valign="top"><a id="a007dfd9ff62ed582860b7867e80d4f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a007dfd9ff62ed582860b7867e80d4f30">nodes</a> (const std::vector&lt; <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a007dfd9ff62ed582860b7867e80d4f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the nodes_ <br /></td></tr>
<tr class="separator:a007dfd9ff62ed582860b7867e80d4f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb4a1514e774e613adb989315bb416"><td class="memItemLeft" align="right" valign="top"><a id="ac3fb4a1514e774e613adb989315bb416"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ac3fb4a1514e774e613adb989315bb416">inputs</a> (const std::vector&lt; uint32_t &gt; &amp;inputs)</td></tr>
<tr class="memdesc:ac3fb4a1514e774e613adb989315bb416"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the inputs_ <br /></td></tr>
<tr class="separator:ac3fb4a1514e774e613adb989315bb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98097e7937496be394b19071810870b2"><td class="memItemLeft" align="right" valign="top"><a id="a98097e7937496be394b19071810870b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a98097e7937496be394b19071810870b2">outputs</a> (const std::vector&lt; uint32_t &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a98097e7937496be394b19071810870b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the outputs_ <br /></td></tr>
<tr class="separator:a98097e7937496be394b19071810870b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b437c69654229560696e0cac558b0d"><td class="memItemLeft" align="right" valign="top"><a id="a96b437c69654229560696e0cac558b0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a96b437c69654229560696e0cac558b0d">adj_mat</a> (std::vector&lt; std::vector&lt; <a class="el" href="classSharqit_1_1ZXEdge.html">ZXEdge</a> &gt;&gt; &amp;adj_mat)</td></tr>
<tr class="memdesc:a96b437c69654229560696e0cac558b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter of the adj_mat_ <br /></td></tr>
<tr class="separator:a96b437c69654229560696e0cac558b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea0db4f999c0f9e3f554ec86c28029c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a0ea0db4f999c0f9e3f554ec86c28029c">to_string</a> () const</td></tr>
<tr class="memdesc:a0ea0db4f999c0f9e3f554ec86c28029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a string of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object  <a href="classSharqit_1_1ZXDiagram.html#a0ea0db4f999c0f9e3f554ec86c28029c">More...</a><br /></td></tr>
<tr class="separator:a0ea0db4f999c0f9e3f554ec86c28029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5080ddd58fa103591d5884fddab72cf"><td class="memItemLeft" align="right" valign="top"><a id="aa5080ddd58fa103591d5884fddab72cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa5080ddd58fa103591d5884fddab72cf">show</a> () const</td></tr>
<tr class="memdesc:aa5080ddd58fa103591d5884fddab72cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">show the ZX-diagram <br /></td></tr>
<tr class="separator:aa5080ddd58fa103591d5884fddab72cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad25b0079e62dbe6036ab7bd8c8af16"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#afad25b0079e62dbe6036ab7bd8c8af16">stats</a> () const</td></tr>
<tr class="memdesc:afad25b0079e62dbe6036ab7bd8c8af16"><td class="mdescLeft">&#160;</td><td class="mdescRight">get stats of the ZX-diagram  <a href="classSharqit_1_1ZXDiagram.html#afad25b0079e62dbe6036ab7bd8c8af16">More...</a><br /></td></tr>
<tr class="separator:afad25b0079e62dbe6036ab7bd8c8af16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3b23c18d64d8ca65810af82f268ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ada3b23c18d64d8ca65810af82f268ec7">to_dot_file</a> (const std::string &amp;file_name) const</td></tr>
<tr class="memdesc:ada3b23c18d64d8ca65810af82f268ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">save as a dot file  <a href="classSharqit_1_1ZXDiagram.html#ada3b23c18d64d8ca65810af82f268ec7">More...</a><br /></td></tr>
<tr class="separator:ada3b23c18d64d8ca65810af82f268ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566b72cce5ddf2299f6d6730913725c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a566b72cce5ddf2299f6d6730913725c9">to_svg_file</a> (const std::string &amp;file_name) const</td></tr>
<tr class="memdesc:a566b72cce5ddf2299f6d6730913725c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">save as a svg file  <a href="classSharqit_1_1ZXDiagram.html#a566b72cce5ddf2299f6d6730913725c9">More...</a><br /></td></tr>
<tr class="separator:a566b72cce5ddf2299f6d6730913725c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88c1b3683b57366762745f0801a78dc"><td class="memItemLeft" align="right" valign="top"><a id="ad88c1b3683b57366762745f0801a78dc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ad88c1b3683b57366762745f0801a78dc">spider_count</a> () const</td></tr>
<tr class="memdesc:ad88c1b3683b57366762745f0801a78dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a spider-count <br /></td></tr>
<tr class="separator:ad88c1b3683b57366762745f0801a78dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699e27dd270d7943f5750dc2a7ead05"><td class="memItemLeft" align="right" valign="top"><a id="ac699e27dd270d7943f5750dc2a7ead05"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ac699e27dd270d7943f5750dc2a7ead05">non_clifford_count</a> () const</td></tr>
<tr class="memdesc:ac699e27dd270d7943f5750dc2a7ead05"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a non-clifford-count <br /></td></tr>
<tr class="separator:ac699e27dd270d7943f5750dc2a7ead05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ffb4dec0ea886eec748af7c5476a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a09ffb4dec0ea886eec748af7c5476a4f">add_qgate</a> (const <a class="el" href="classSharqit_1_1QGate.html">QGate</a> &amp;qgate)</td></tr>
<tr class="memdesc:a09ffb4dec0ea886eec748af7c5476a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a quantum gate to the ZX-diagram  <a href="classSharqit_1_1ZXDiagram.html#a09ffb4dec0ea886eec748af7c5476a4f">More...</a><br /></td></tr>
<tr class="separator:a09ffb4dec0ea886eec748af7c5476a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c96bbcf8e67965d474bc0f32bb559b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ab9c96bbcf8e67965d474bc0f32bb559b">append_node</a> (const <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a> node)</td></tr>
<tr class="memdesc:ab9c96bbcf8e67965d474bc0f32bb559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a node of ZX-diagram  <a href="classSharqit_1_1ZXDiagram.html#ab9c96bbcf8e67965d474bc0f32bb559b">More...</a><br /></td></tr>
<tr class="separator:ab9c96bbcf8e67965d474bc0f32bb559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9456944954706294741f2434524c2d89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a9456944954706294741f2434524c2d89">append_node</a> (const <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a> node, const <a class="el" href="classSharqit_1_1ZXEdge.html">ZXEdge</a> edge)</td></tr>
<tr class="memdesc:a9456944954706294741f2434524c2d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a node and an edge connected to the node  <a href="classSharqit_1_1ZXDiagram.html#a9456944954706294741f2434524c2d89">More...</a><br /></td></tr>
<tr class="separator:a9456944954706294741f2434524c2d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a6cd8f0f824386f8c94b0e2fe5526f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a93a6cd8f0f824386f8c94b0e2fe5526f">connect_nodes</a> (const uint32_t a, const uint32_t b, const <a class="el" href="zx_8h.html#a313f1181cb769f2e489b6e35219287d1">ZXEdgeKind</a> <a class="el" href="classSharqit_1_1ZXDiagram.html#af076c0c4841ff6f554dbe2e72ae4f2dd">kind</a>)</td></tr>
<tr class="memdesc:a93a6cd8f0f824386f8c94b0e2fe5526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make an edge connected two nodes specified the indexes, and assign the kind to the edge  <a href="classSharqit_1_1ZXDiagram.html#a93a6cd8f0f824386f8c94b0e2fe5526f">More...</a><br /></td></tr>
<tr class="separator:a93a6cd8f0f824386f8c94b0e2fe5526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce955f0b9eb8dbdd93dd3671b928c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a313f1181cb769f2e489b6e35219287d1">ZXEdgeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#acce955f0b9eb8dbdd93dd3671b928c5b">remove_edge</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:acce955f0b9eb8dbdd93dd3671b928c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove an edge between two nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#acce955f0b9eb8dbdd93dd3671b928c5b">More...</a><br /></td></tr>
<tr class="separator:acce955f0b9eb8dbdd93dd3671b928c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61675e2cd9aa777a2ffbb637436c2f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a61675e2cd9aa777a2ffbb637436c2f30">update_node_places</a> ()</td></tr>
<tr class="memdesc:a61675e2cd9aa777a2ffbb637436c2f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the vector of the node places  <a href="classSharqit_1_1ZXDiagram.html#a61675e2cd9aa777a2ffbb637436c2f30">More...</a><br /></td></tr>
<tr class="separator:a61675e2cd9aa777a2ffbb637436c2f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d01b0c9c7b99a598327305261bbf9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a57d01b0c9c7b99a598327305261bbf9a">update_phase_gadget</a> ()</td></tr>
<tr class="memdesc:a57d01b0c9c7b99a598327305261bbf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the vector of the phase gadget  <a href="classSharqit_1_1ZXDiagram.html#a57d01b0c9c7b99a598327305261bbf9a">More...</a><br /></td></tr>
<tr class="separator:a57d01b0c9c7b99a598327305261bbf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e70a0a743b6aa14c7e32353c2dcdd"><td class="memItemLeft" align="right" valign="top"><a id="a7b4e70a0a743b6aa14c7e32353c2dcdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a7b4e70a0a743b6aa14c7e32353c2dcdd">graph_like</a> ()</td></tr>
<tr class="memdesc:a7b4e70a0a743b6aa14c7e32353c2dcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the ZX-diagram to the graph-like ZX-diagram <br /></td></tr>
<tr class="separator:a7b4e70a0a743b6aa14c7e32353c2dcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a7d5b4ac607783b611af43136cd071"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a79a7d5b4ac607783b611af43136cd071">lcomp</a> ()</td></tr>
<tr class="memdesc:a79a7d5b4ac607783b611af43136cd071"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a local complimmentation algorithm  <a href="classSharqit_1_1ZXDiagram.html#a79a7d5b4ac607783b611af43136cd071">More...</a><br /></td></tr>
<tr class="separator:a79a7d5b4ac607783b611af43136cd071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98914b21c0504caa093953755a405fe7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a98914b21c0504caa093953755a405fe7">pivot1</a> ()</td></tr>
<tr class="memdesc:a98914b21c0504caa093953755a405fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot1 algorithm  <a href="classSharqit_1_1ZXDiagram.html#a98914b21c0504caa093953755a405fe7">More...</a><br /></td></tr>
<tr class="separator:a98914b21c0504caa093953755a405fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d8caa625a45f2b36be6ab0e30b7945"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#af2d8caa625a45f2b36be6ab0e30b7945">pivot2</a> ()</td></tr>
<tr class="memdesc:af2d8caa625a45f2b36be6ab0e30b7945"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot2 algorithm  <a href="classSharqit_1_1ZXDiagram.html#af2d8caa625a45f2b36be6ab0e30b7945">More...</a><br /></td></tr>
<tr class="separator:af2d8caa625a45f2b36be6ab0e30b7945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9745272bf37c2591dc52de591f70160b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a9745272bf37c2591dc52de591f70160b">pivot3</a> ()</td></tr>
<tr class="memdesc:a9745272bf37c2591dc52de591f70160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot3 algorithm  <a href="classSharqit_1_1ZXDiagram.html#a9745272bf37c2591dc52de591f70160b">More...</a><br /></td></tr>
<tr class="separator:a9745272bf37c2591dc52de591f70160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a961b51bd598cb9abe573a45d67b1d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a44a961b51bd598cb9abe573a45d67b1d">gfusion</a> ()</td></tr>
<tr class="memdesc:a44a961b51bd598cb9abe573a45d67b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a gadget fusion algorithm  <a href="classSharqit_1_1ZXDiagram.html#a44a961b51bd598cb9abe573a45d67b1d">More...</a><br /></td></tr>
<tr class="separator:a44a961b51bd598cb9abe573a45d67b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3781aa9ab89acae14fcb38bf5465e0de"><td class="memItemLeft" align="right" valign="top"><a id="a3781aa9ab89acae14fcb38bf5465e0de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a3781aa9ab89acae14fcb38bf5465e0de">id_removal</a> ()</td></tr>
<tr class="memdesc:a3781aa9ab89acae14fcb38bf5465e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all identity spiders <br /></td></tr>
<tr class="separator:a3781aa9ab89acae14fcb38bf5465e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74a75321753b50fa089fcc73568aa27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ae74a75321753b50fa089fcc73568aa27">simplify</a> ()</td></tr>
<tr class="memdesc:ae74a75321753b50fa089fcc73568aa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplify the ZX-diagram  <a href="classSharqit_1_1ZXDiagram.html#ae74a75321753b50fa089fcc73568aa27">More...</a><br /></td></tr>
<tr class="separator:ae74a75321753b50fa089fcc73568aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069a710d311a0e470a47b8eecbaeaae1"><td class="memItemLeft" align="right" valign="top"><a id="a069a710d311a0e470a47b8eecbaeaae1"></a>
<a class="el" href="classSharqit_1_1QCirc.html">QCirc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a069a710d311a0e470a47b8eecbaeaae1">extract_qcirc</a> ()</td></tr>
<tr class="memdesc:a069a710d311a0e470a47b8eecbaeaae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a quantum circuit from the graph-like ZX-diagram <br /></td></tr>
<tr class="separator:a069a710d311a0e470a47b8eecbaeaae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ace461dfcd62ab985418cfd29732ac7e2"><td class="memItemLeft" align="right" valign="top"><a id="ace461dfcd62ab985418cfd29732ac7e2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ace461dfcd62ab985418cfd29732ac7e2">max_adj_num</a> () const</td></tr>
<tr class="memdesc:ace461dfcd62ab985418cfd29732ac7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a maximum number of the adjacent nodes <br /></td></tr>
<tr class="separator:ace461dfcd62ab985418cfd29732ac7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657567ef4cc9864e5f4393c421ac4200"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a657567ef4cc9864e5f4393c421ac4200">check_x_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a657567ef4cc9864e5f4393c421ac4200"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a X spider or not  <a href="classSharqit_1_1ZXDiagram.html#a657567ef4cc9864e5f4393c421ac4200">More...</a><br /></td></tr>
<tr class="separator:a657567ef4cc9864e5f4393c421ac4200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8960b1d730f0d7ae95bc6fdb97f015e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a8960b1d730f0d7ae95bc6fdb97f015e1">check_z_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a8960b1d730f0d7ae95bc6fdb97f015e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a Z spider or not  <a href="classSharqit_1_1ZXDiagram.html#a8960b1d730f0d7ae95bc6fdb97f015e1">More...</a><br /></td></tr>
<tr class="separator:a8960b1d730f0d7ae95bc6fdb97f015e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fe901d795572242540545aba8fe664"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a94fe901d795572242540545aba8fe664">check_zero_phase_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a94fe901d795572242540545aba8fe664"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a zero phase spider or not  <a href="classSharqit_1_1ZXDiagram.html#a94fe901d795572242540545aba8fe664">More...</a><br /></td></tr>
<tr class="separator:a94fe901d795572242540545aba8fe664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8cb6706fd9ac9181fd676ebd7456d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a0d8cb6706fd9ac9181fd676ebd7456d9">check_pauli_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a0d8cb6706fd9ac9181fd676ebd7456d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a pauli spider or not  <a href="classSharqit_1_1ZXDiagram.html#a0d8cb6706fd9ac9181fd676ebd7456d9">More...</a><br /></td></tr>
<tr class="separator:a0d8cb6706fd9ac9181fd676ebd7456d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66aa5faca974c4c25ccb74a2f4c0a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a4a66aa5faca974c4c25ccb74a2f4c0a9">check_proper_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a4a66aa5faca974c4c25ccb74a2f4c0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a proper clifford spider or not  <a href="classSharqit_1_1ZXDiagram.html#a4a66aa5faca974c4c25ccb74a2f4c0a9">More...</a><br /></td></tr>
<tr class="separator:a4a66aa5faca974c4c25ccb74a2f4c0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb521c7e8ff70dd898569d2ad4d762e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#adeb521c7e8ff70dd898569d2ad4d762e">check_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:adeb521c7e8ff70dd898569d2ad4d762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a clifford spider or not  <a href="classSharqit_1_1ZXDiagram.html#adeb521c7e8ff70dd898569d2ad4d762e">More...</a><br /></td></tr>
<tr class="separator:adeb521c7e8ff70dd898569d2ad4d762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02c5033088f25eabbb9f2b4d0c138c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa02c5033088f25eabbb9f2b4d0c138c7">check_non_clifford_spider</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:aa02c5033088f25eabbb9f2b4d0c138c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a non-clifford spider or not  <a href="classSharqit_1_1ZXDiagram.html#aa02c5033088f25eabbb9f2b4d0c138c7">More...</a><br /></td></tr>
<tr class="separator:aa02c5033088f25eabbb9f2b4d0c138c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685a49f183f58d2f296587d01b44fbbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a685a49f183f58d2f296587d01b44fbbe">check_internal_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a685a49f183f58d2f296587d01b44fbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a internal node or not  <a href="classSharqit_1_1ZXDiagram.html#a685a49f183f58d2f296587d01b44fbbe">More...</a><br /></td></tr>
<tr class="separator:a685a49f183f58d2f296587d01b44fbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6876d1a3709dd5a1e8014d82985ba2d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a6876d1a3709dd5a1e8014d82985ba2d8">check_boundary_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a6876d1a3709dd5a1e8014d82985ba2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a boundary node or not  <a href="classSharqit_1_1ZXDiagram.html#a6876d1a3709dd5a1e8014d82985ba2d8">More...</a><br /></td></tr>
<tr class="separator:a6876d1a3709dd5a1e8014d82985ba2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf547b649c21e3d70d1e956d55bff933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#abf547b649c21e3d70d1e956d55bff933">check_pg_phase_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:abf547b649c21e3d70d1e956d55bff933"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a phase node of a phase gadget or not  <a href="classSharqit_1_1ZXDiagram.html#abf547b649c21e3d70d1e956d55bff933">More...</a><br /></td></tr>
<tr class="separator:abf547b649c21e3d70d1e956d55bff933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4908cb402983fc84ba629dc0d55a19e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ab4908cb402983fc84ba629dc0d55a19e">check_pg_root_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ab4908cb402983fc84ba629dc0d55a19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a root node of a phase gadget or not  <a href="classSharqit_1_1ZXDiagram.html#ab4908cb402983fc84ba629dc0d55a19e">More...</a><br /></td></tr>
<tr class="separator:ab4908cb402983fc84ba629dc0d55a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcb92f1cc26978d455cd225175f1352"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a8bcb92f1cc26978d455cd225175f1352">check_pg_leaf_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a8bcb92f1cc26978d455cd225175f1352"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a leaf node of a phase gadget or not  <a href="classSharqit_1_1ZXDiagram.html#a8bcb92f1cc26978d455cd225175f1352">More...</a><br /></td></tr>
<tr class="separator:a8bcb92f1cc26978d455cd225175f1352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca947e2c53ee1d1ee64db03754e904cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aca947e2c53ee1d1ee64db03754e904cd">check_phase_gadget_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:aca947e2c53ee1d1ee64db03754e904cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a node of a phase gadget (phase or root) or not  <a href="classSharqit_1_1ZXDiagram.html#aca947e2c53ee1d1ee64db03754e904cd">More...</a><br /></td></tr>
<tr class="separator:aca947e2c53ee1d1ee64db03754e904cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f2223598f4038a727918743473e930"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a15f2223598f4038a727918743473e930">check_input_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:a15f2223598f4038a727918743473e930"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a input node or not  <a href="classSharqit_1_1ZXDiagram.html#a15f2223598f4038a727918743473e930">More...</a><br /></td></tr>
<tr class="separator:a15f2223598f4038a727918743473e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e68c88eb86b19757d5ab49c365a265"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ab6e68c88eb86b19757d5ab49c365a265">check_output_node</a> (const uint32_t node_index) const</td></tr>
<tr class="memdesc:ab6e68c88eb86b19757d5ab49c365a265"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index is a output node or not  <a href="classSharqit_1_1ZXDiagram.html#ab6e68c88eb86b19757d5ab49c365a265">More...</a><br /></td></tr>
<tr class="separator:ab6e68c88eb86b19757d5ab49c365a265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3c31a77d02776890e95a5e0ef75ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a9e3c31a77d02776890e95a5e0ef75ecb">check_connect_input_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a9e3c31a77d02776890e95a5e0ef75ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a input node or not  <a href="classSharqit_1_1ZXDiagram.html#a9e3c31a77d02776890e95a5e0ef75ecb">More...</a><br /></td></tr>
<tr class="separator:a9e3c31a77d02776890e95a5e0ef75ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f41cd0bc3cfeaaa26f2db08ebcc58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a489f41cd0bc3cfeaaa26f2db08ebcc58">check_connect_output_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a489f41cd0bc3cfeaaa26f2db08ebcc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a output node or not  <a href="classSharqit_1_1ZXDiagram.html#a489f41cd0bc3cfeaaa26f2db08ebcc58">More...</a><br /></td></tr>
<tr class="separator:a489f41cd0bc3cfeaaa26f2db08ebcc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977eb30464659be9a6aa26cdd1f164b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a977eb30464659be9a6aa26cdd1f164b6">check_connect_phase_gadget</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a977eb30464659be9a6aa26cdd1f164b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the node specified in this index connects a phase gadget (phase or root) or not  <a href="classSharqit_1_1ZXDiagram.html#a977eb30464659be9a6aa26cdd1f164b6">More...</a><br /></td></tr>
<tr class="separator:a977eb30464659be9a6aa26cdd1f164b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8804270b45fc4c3738aa0bb19a984ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa8804270b45fc4c3738aa0bb19a984ec">check_connect</a> (const uint32_t a, const uint32_t b) const</td></tr>
<tr class="memdesc:aa8804270b45fc4c3738aa0bb19a984ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the two nodes specified in these indexes are connected or not  <a href="classSharqit_1_1ZXDiagram.html#aa8804270b45fc4c3738aa0bb19a984ec">More...</a><br /></td></tr>
<tr class="separator:aa8804270b45fc4c3738aa0bb19a984ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e9a629d1b9ef8afa0753474c2a6dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a54e9a629d1b9ef8afa0753474c2a6dbd">xor_hadamard_edge</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:a54e9a629d1b9ef8afa0753474c2a6dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">operate XOR by the hadamard edge between two nodes specified in these indexes  <a href="classSharqit_1_1ZXDiagram.html#a54e9a629d1b9ef8afa0753474c2a6dbd">More...</a><br /></td></tr>
<tr class="separator:a54e9a629d1b9ef8afa0753474c2a6dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658d4267cf74af398e8d723d7955ac43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a658d4267cf74af398e8d723d7955ac43">xor_hadamard_edges</a> (std::vector&lt; uint32_t &gt; node_indexes)</td></tr>
<tr class="memdesc:a658d4267cf74af398e8d723d7955ac43"><td class="mdescLeft">&#160;</td><td class="mdescRight">operate XOR by the all hadamard edges composed by any pair of two nodes  <a href="classSharqit_1_1ZXDiagram.html#a658d4267cf74af398e8d723d7955ac43">More...</a><br /></td></tr>
<tr class="separator:a658d4267cf74af398e8d723d7955ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f543725ae8d27a30b1999c56e29d96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a54e98198a3a6549ebb7b154384a5a28d">ZXNodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a6f543725ae8d27a30b1999c56e29d96e">remove_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a6f543725ae8d27a30b1999c56e29d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#a6f543725ae8d27a30b1999c56e29d96e">More...</a><br /></td></tr>
<tr class="separator:a6f543725ae8d27a30b1999c56e29d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab69ca055827a468490ada3b8aa5a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a25ab69ca055827a468490ada3b8aa5a4">remove_edges_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a25ab69ca055827a468490ada3b8aa5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all edges connected to the node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#a25ab69ca055827a468490ada3b8aa5a4">More...</a><br /></td></tr>
<tr class="separator:a25ab69ca055827a468490ada3b8aa5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3e7c355c35e3af2272728baa9055c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ace3e7c355c35e3af2272728baa9055c0">degree_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:ace3e7c355c35e3af2272728baa9055c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a degree of the node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#ace3e7c355c35e3af2272728baa9055c0">More...</a><br /></td></tr>
<tr class="separator:ace3e7c355c35e3af2272728baa9055c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3b032dc9dd63c1e5efc3e9fafc7d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zx_8h.html#a54e98198a3a6549ebb7b154384a5a28d">ZXNodeKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a2b3b032dc9dd63c1e5efc3e9fafc7d08">kind_of_node</a> (const uint32_t node_index)</td></tr>
<tr class="memdesc:a2b3b032dc9dd63c1e5efc3e9fafc7d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a kind of the node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#a2b3b032dc9dd63c1e5efc3e9fafc7d08">More...</a><br /></td></tr>
<tr class="separator:a2b3b032dc9dd63c1e5efc3e9fafc7d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09e2a045862929cc496881dc44eaa23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa09e2a045862929cc496881dc44eaa23">swap_nodes</a> (uint32_t i, uint32_t j)</td></tr>
<tr class="memdesc:aa09e2a045862929cc496881dc44eaa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#aa09e2a045862929cc496881dc44eaa23">More...</a><br /></td></tr>
<tr class="separator:aa09e2a045862929cc496881dc44eaa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947788d0c0458aeeac5228b4015552de"><td class="memItemLeft" align="right" valign="top"><a id="a947788d0c0458aeeac5228b4015552de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a947788d0c0458aeeac5228b4015552de">remove_isolated_spiders</a> ()</td></tr>
<tr class="memdesc:a947788d0c0458aeeac5228b4015552de"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove isolated spiders <br /></td></tr>
<tr class="separator:a947788d0c0458aeeac5228b4015552de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd43b4fccb7bfecc596af864dd3fbfc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#abd43b4fccb7bfecc596af864dd3fbfc2">row_operation</a> (const uint32_t a, const uint32_t b)</td></tr>
<tr class="memdesc:abd43b4fccb7bfecc596af864dd3fbfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute row operation for the two nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#abd43b4fccb7bfecc596af864dd3fbfc2">More...</a><br /></td></tr>
<tr class="separator:abd43b4fccb7bfecc596af864dd3fbfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67996e148fd1133f42704c47359e6710"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a67996e148fd1133f42704c47359e6710">adjacent_node_indexes</a> (uint32_t node_index)</td></tr>
<tr class="memdesc:a67996e148fd1133f42704c47359e6710"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of nodes adjacent to the node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#a67996e148fd1133f42704c47359e6710">More...</a><br /></td></tr>
<tr class="separator:a67996e148fd1133f42704c47359e6710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b3e523ee1fd0fb414009be64fc1a2"><td class="memItemLeft" align="right" valign="top"><a id="aaf6b3e523ee1fd0fb414009be64fc1a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aaf6b3e523ee1fd0fb414009be64fc1a2">conv_x_to_z</a> ()</td></tr>
<tr class="memdesc:aaf6b3e523ee1fd0fb414009be64fc1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert all X spiders to Z spiders with hadamard edges <br /></td></tr>
<tr class="separator:aaf6b3e523ee1fd0fb414009be64fc1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8282ba8e016344b7e821952f995576d8"><td class="memItemLeft" align="right" valign="top"><a id="a8282ba8e016344b7e821952f995576d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a8282ba8e016344b7e821952f995576d8">fuse_spiders</a> ()</td></tr>
<tr class="memdesc:a8282ba8e016344b7e821952f995576d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuse all spiders <br /></td></tr>
<tr class="separator:a8282ba8e016344b7e821952f995576d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061d11947057d065ec8822d9b8bab6a5"><td class="memItemLeft" align="right" valign="top"><a id="a061d11947057d065ec8822d9b8bab6a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a061d11947057d065ec8822d9b8bab6a5">remove_parallel_selfloops_hadamard_edges</a> ()</td></tr>
<tr class="memdesc:a061d11947057d065ec8822d9b8bab6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all parallel hadamard edges and self-looped hadamard edges <br /></td></tr>
<tr class="separator:a061d11947057d065ec8822d9b8bab6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a03a71663ac33a076cea81f6c0396f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ad4a03a71663ac33a076cea81f6c0396f">permutation_as_swap</a> (<a class="el" href="classSharqit_1_1QCirc.html">QCirc</a> &amp;qc)</td></tr>
<tr class="memdesc:ad4a03a71663ac33a076cea81f6c0396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">add swap gates to reorder the swapped qubit indexes to the original order in process of extracting the quantum circuit  <a href="classSharqit_1_1ZXDiagram.html#ad4a03a71663ac33a076cea81f6c0396f">More...</a><br /></td></tr>
<tr class="separator:ad4a03a71663ac33a076cea81f6c0396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2560f940a5d3a8834def6b84752f6728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a2560f940a5d3a8834def6b84752f6728">process_frontier</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;qc, const bool opt_cz=false)</td></tr>
<tr class="memdesc:a2560f940a5d3a8834def6b84752f6728"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the frontier spiders initially  <a href="classSharqit_1_1ZXDiagram.html#a2560f940a5d3a8834def6b84752f6728">More...</a><br /></td></tr>
<tr class="separator:a2560f940a5d3a8834def6b84752f6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78505be31339d22ba90fff6cb3016870"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a78505be31339d22ba90fff6cb3016870">update_frontier</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;qc, const bool opt_cz=false)</td></tr>
<tr class="memdesc:a78505be31339d22ba90fff6cb3016870"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract quantum gates from the ZX-diagram and update the frontier spiders  <a href="classSharqit_1_1ZXDiagram.html#a78505be31339d22ba90fff6cb3016870">More...</a><br /></td></tr>
<tr class="separator:a78505be31339d22ba90fff6cb3016870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc821db28c10af7ee3d54bca5a8beab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#acdc821db28c10af7ee3d54bca5a8beab">update_frontier_pg</a> (std::vector&lt; uint32_t &gt; &amp;frontier, <a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;qc)</td></tr>
<tr class="memdesc:acdc821db28c10af7ee3d54bca5a8beab"><td class="mdescLeft">&#160;</td><td class="mdescRight">update frontier spiders in the case that the frontier can't be updated because of invalid biadjacency matrix related to the frontier  <a href="classSharqit_1_1ZXDiagram.html#acdc821db28c10af7ee3d54bca5a8beab">More...</a><br /></td></tr>
<tr class="separator:acdc821db28c10af7ee3d54bca5a8beab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437040102fd820b57837316cc4ec0cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a7437040102fd820b57837316cc4ec0cb">lcomp_one_time</a> (const uint32_t idx_A)</td></tr>
<tr class="memdesc:a7437040102fd820b57837316cc4ec0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a local complimmentation algorithm for the node specified in the index  <a href="classSharqit_1_1ZXDiagram.html#a7437040102fd820b57837316cc4ec0cb">More...</a><br /></td></tr>
<tr class="separator:a7437040102fd820b57837316cc4ec0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367d5e853e0e3fa902389995028675cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a367d5e853e0e3fa902389995028675cc">pivot1_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:a367d5e853e0e3fa902389995028675cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot1 algorithm for the nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#a367d5e853e0e3fa902389995028675cc">More...</a><br /></td></tr>
<tr class="separator:a367d5e853e0e3fa902389995028675cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff83d1ade4f126f47e8ab3c61a3c41b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#afff83d1ade4f126f47e8ab3c61a3c41b">pivot2_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:afff83d1ade4f126f47e8ab3c61a3c41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot2 algorithm for the nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#afff83d1ade4f126f47e8ab3c61a3c41b">More...</a><br /></td></tr>
<tr class="separator:afff83d1ade4f126f47e8ab3c61a3c41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25fd543788b8b8030c7bc03903317be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa25fd543788b8b8030c7bc03903317be">pivot3_one_time</a> (const uint32_t idx_A, const uint32_t idx_B)</td></tr>
<tr class="memdesc:aa25fd543788b8b8030c7bc03903317be"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a pivot3 algorithm for the nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#aa25fd543788b8b8030c7bc03903317be">More...</a><br /></td></tr>
<tr class="separator:aa25fd543788b8b8030c7bc03903317be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccbfdfca7986229324f1d8d3fb0826a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a8ccbfdfca7986229324f1d8d3fb0826a">gfusion_one_time</a> (const uint32_t idx_A_phase, const uint32_t idx_B_phase)</td></tr>
<tr class="memdesc:a8ccbfdfca7986229324f1d8d3fb0826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply a gadget fusion algorithm for the nodes specified in the indexes  <a href="classSharqit_1_1ZXDiagram.html#a8ccbfdfca7986229324f1d8d3fb0826a">More...</a><br /></td></tr>
<tr class="separator:a8ccbfdfca7986229324f1d8d3fb0826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c28259b9d73227de7bed6eb8e7a2b23"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a9c28259b9d73227de7bed6eb8e7a2b23">extract_2q_connects</a> (std::vector&lt; uint32_t &gt; &amp;frontier) const</td></tr>
<tr class="memdesc:a9c28259b9d73227de7bed6eb8e7a2b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract 2Q connections from the frontier (for CZ optimization in the update_frontier function)  <a href="classSharqit_1_1ZXDiagram.html#a9c28259b9d73227de7bed6eb8e7a2b23">More...</a><br /></td></tr>
<tr class="separator:a9c28259b9d73227de7bed6eb8e7a2b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a30f7c06a04f8420233ca2678f8172936"><td class="memItemLeft" align="right" valign="top"><a id="a30f7c06a04f8420233ca2678f8172936"></a>
<a class="el" href="zx_8h.html#a68fd425089a9de35d5479f458f791cdd">ZXDiagramKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a30f7c06a04f8420233ca2678f8172936">kind_</a></td></tr>
<tr class="memdesc:a30f7c06a04f8420233ca2678f8172936"><td class="mdescLeft">&#160;</td><td class="mdescRight">kind of the ZX-diagram <br /></td></tr>
<tr class="separator:a30f7c06a04f8420233ca2678f8172936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d60b3c431f75e8d028f9954cb769f4f"><td class="memItemLeft" align="right" valign="top"><a id="a7d60b3c431f75e8d028f9954cb769f4f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a7d60b3c431f75e8d028f9954cb769f4f">qubit_num_</a></td></tr>
<tr class="memdesc:a7d60b3c431f75e8d028f9954cb769f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of qubits <br /></td></tr>
<tr class="separator:a7d60b3c431f75e8d028f9954cb769f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2872bbbbd5a3bd674821c3a8d1447b22"><td class="memItemLeft" align="right" valign="top"><a id="a2872bbbbd5a3bd674821c3a8d1447b22"></a>
std::vector&lt; <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a2872bbbbd5a3bd674821c3a8d1447b22">nodes_</a></td></tr>
<tr class="memdesc:a2872bbbbd5a3bd674821c3a8d1447b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the <a class="el" href="classSharqit_1_1ZXNode.html" title="node of ZX-diagram">ZXNode</a> objects <br /></td></tr>
<tr class="separator:a2872bbbbd5a3bd674821c3a8d1447b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add04174edfe5af67b2bc2d2c3b12c68b"><td class="memItemLeft" align="right" valign="top"><a id="add04174edfe5af67b2bc2d2c3b12c68b"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#add04174edfe5af67b2bc2d2c3b12c68b">inputs_</a></td></tr>
<tr class="memdesc:add04174edfe5af67b2bc2d2c3b12c68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the input node indexes <br /></td></tr>
<tr class="separator:add04174edfe5af67b2bc2d2c3b12c68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46992205d901ca274fa5feb0c65ea8b"><td class="memItemLeft" align="right" valign="top"><a id="ac46992205d901ca274fa5feb0c65ea8b"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#ac46992205d901ca274fa5feb0c65ea8b">outputs_</a></td></tr>
<tr class="memdesc:ac46992205d901ca274fa5feb0c65ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the output node indexes <br /></td></tr>
<tr class="separator:ac46992205d901ca274fa5feb0c65ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d483150a00c0d957302400d168ba1c8"><td class="memItemLeft" align="right" valign="top"><a id="a8d483150a00c0d957302400d168ba1c8"></a>
std::vector&lt; std::vector&lt; <a class="el" href="classSharqit_1_1ZXEdge.html">ZXEdge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#a8d483150a00c0d957302400d168ba1c8">adj_mat_</a></td></tr>
<tr class="memdesc:a8d483150a00c0d957302400d168ba1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacent matrix of the ZX-diagram <br /></td></tr>
<tr class="separator:a8d483150a00c0d957302400d168ba1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff1d1b1dcd0370718e3ba9ce1b060e"><td class="memItemLeft" align="right" valign="top"><a id="aa6ff1d1b1dcd0370718e3ba9ce1b060e"></a>
std::vector&lt; <a class="el" href="zx_8h.html#af2d84e2de87bd75d55d223504e45ce58">ZXNodePlace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSharqit_1_1ZXDiagram.html#aa6ff1d1b1dcd0370718e3ba9ce1b060e">node_places_</a></td></tr>
<tr class="memdesc:aa6ff1d1b1dcd0370718e3ba9ce1b060e"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of the node places (Terminal, Boundary or Internal) <br /></td></tr>
<tr class="separator:aa6ff1d1b1dcd0370718e3ba9ce1b060e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af6bdef1f0bca5036a8df8f8e801ac541"><td class="memItemLeft" align="right" valign="top"><a id="af6bdef1f0bca5036a8df8f8e801ac541"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;ost, const <a class="el" href="classSharqit_1_1ZXDiagram.html">ZXDiagram</a> &amp;zx)</td></tr>
<tr class="separator:af6bdef1f0bca5036a8df8f8e801ac541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ZX-diagram. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXNode.html" title="node of ZX-diagram">ZXNode</a> </dd>
<dd>
<a class="el" href="classSharqit_1_1ZXEdge.html" title="edge of ZX-diagram">ZXEdge</a> </dd>
<dd>
1. Ross Duncan, Aleks Kissinger, Simon Perdrix, John van de Wetering, "Graph-theoretic Simplification of Quantum Circuits with the ZX-calculus", <a href="https://arxiv.org/abs/1902.03178">arXiv:1902.03178</a> </dd>
<dd>
2. Aleks Kissinger, John van de Wetering, "Reducing T-count with the ZX-calculus", <a href="https://arxiv.org/abs/1903.10477">arXiv:1903.10477</a> </dd>
<dd>
3. Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski, John van de Wetering, "There and back again: A circuit extraction tale", <a href="https://arxiv.org/abs/2003.01664">arXiv:2003.01664</a> </dd>
<dd>
4. Korbinian Staudacher, "Optimization Approaches for Quantum Circuits using ZX-calculus" <a href="https://www.mnm-team.org/pub/Diplomarbeiten/stau21/PDF-Version/stau21.pdf">Ludwig maximilian university of munich thesis</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a691e1b8b827437500767e39ea6db9adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691e1b8b827437500767e39ea6db9adf">&#9670;&nbsp;</a></span>ZXDiagram() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sharqit::ZXDiagram::ZXDiagram </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>qubit_num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qubit_num</td><td>number of qubits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae61d61c08cceda949b505515d756e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae61d61c08cceda949b505515d756e51">&#9670;&nbsp;</a></span>ZXDiagram() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sharqit::ZXDiagram::ZXDiagram </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharqit_1_1ZXDiagram.html">ZXDiagram</a> &amp;&#160;</td>
          <td class="paramname"><em>zx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zx</td><td><a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09ffb4dec0ea886eec748af7c5476a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ffb4dec0ea886eec748af7c5476a4f">&#9670;&nbsp;</a></span>add_qgate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::add_qgate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharqit_1_1QGate.html">QGate</a> &amp;&#160;</td>
          <td class="paramname"><em>qgate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a quantum gate to the ZX-diagram </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qgate</td><td>quantum gate added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67996e148fd1133f42704c47359e6710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67996e148fd1133f42704c47359e6710">&#9670;&nbsp;</a></span>adjacent_node_indexes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; Sharqit::ZXDiagram::adjacent_node_indexes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a vector of nodes adjacent to the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of nodes adjacent to the node specified in the index </dd></dl>

</div>
</div>
<a id="ab9c96bbcf8e67965d474bc0f32bb559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c96bbcf8e67965d474bc0f32bb559b">&#9670;&nbsp;</a></span>append_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::append_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append a node of ZX-diagram </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>node of ZX-diagram </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9456944954706294741f2434524c2d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9456944954706294741f2434524c2d89">&#9670;&nbsp;</a></span>append_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::append_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSharqit_1_1ZXNode.html">ZXNode</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSharqit_1_1ZXEdge.html">ZXEdge</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append a node and an edge connected to the node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>node of ZX-diagram </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>edge of ZX-diagram </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6876d1a3709dd5a1e8014d82985ba2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6876d1a3709dd5a1e8014d82985ba2d8">&#9670;&nbsp;</a></span>check_boundary_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_boundary_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a boundary node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a boundary node, false otherwise </dd></dl>

</div>
</div>
<a id="adeb521c7e8ff70dd898569d2ad4d762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb521c7e8ff70dd898569d2ad4d762e">&#9670;&nbsp;</a></span>check_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="aa8804270b45fc4c3738aa0bb19a984ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8804270b45fc4c3738aa0bb19a984ec">&#9670;&nbsp;</a></span>check_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_connect </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the two nodes specified in these indexes are connected or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two nodes specified in these indexes are connected, false otherwise </dd></dl>

</div>
</div>
<a id="a9e3c31a77d02776890e95a5e0ef75ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3c31a77d02776890e95a5e0ef75ecb">&#9670;&nbsp;</a></span>check_connect_input_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_connect_input_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a input node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a input node, false otherwise </dd></dl>

</div>
</div>
<a id="a489f41cd0bc3cfeaaa26f2db08ebcc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489f41cd0bc3cfeaaa26f2db08ebcc58">&#9670;&nbsp;</a></span>check_connect_output_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_connect_output_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a output node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a output node, false otherwise </dd></dl>

</div>
</div>
<a id="a977eb30464659be9a6aa26cdd1f164b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977eb30464659be9a6aa26cdd1f164b6">&#9670;&nbsp;</a></span>check_connect_phase_gadget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_connect_phase_gadget </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index connects a phase gadget (phase or root) or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index connects a phase gadget (phase or root), false otherwise </dd></dl>

</div>
</div>
<a id="a15f2223598f4038a727918743473e930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f2223598f4038a727918743473e930">&#9670;&nbsp;</a></span>check_input_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_input_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a input node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a input node, false otherwise </dd></dl>

</div>
</div>
<a id="a685a49f183f58d2f296587d01b44fbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685a49f183f58d2f296587d01b44fbbe">&#9670;&nbsp;</a></span>check_internal_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_internal_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a internal node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a internal node, false otherwise </dd></dl>

</div>
</div>
<a id="aa02c5033088f25eabbb9f2b4d0c138c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02c5033088f25eabbb9f2b4d0c138c7">&#9670;&nbsp;</a></span>check_non_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_non_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a non-clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a non-clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="ab6e68c88eb86b19757d5ab49c365a265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e68c88eb86b19757d5ab49c365a265">&#9670;&nbsp;</a></span>check_output_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_output_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a output node or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a output node, false otherwise </dd></dl>

</div>
</div>
<a id="a0d8cb6706fd9ac9181fd676ebd7456d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8cb6706fd9ac9181fd676ebd7456d9">&#9670;&nbsp;</a></span>check_pauli_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_pauli_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a pauli spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a pauli spider, false otherwise </dd></dl>

</div>
</div>
<a id="a8bcb92f1cc26978d455cd225175f1352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb92f1cc26978d455cd225175f1352">&#9670;&nbsp;</a></span>check_pg_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_pg_leaf_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a leaf node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a leaf node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="abf547b649c21e3d70d1e956d55bff933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf547b649c21e3d70d1e956d55bff933">&#9670;&nbsp;</a></span>check_pg_phase_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_pg_phase_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a phase node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a phase node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="ab4908cb402983fc84ba629dc0d55a19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4908cb402983fc84ba629dc0d55a19e">&#9670;&nbsp;</a></span>check_pg_root_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_pg_root_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a root node of a phase gadget or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a root node of a phase gadget, false otherwise </dd></dl>

</div>
</div>
<a id="aca947e2c53ee1d1ee64db03754e904cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca947e2c53ee1d1ee64db03754e904cd">&#9670;&nbsp;</a></span>check_phase_gadget_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_phase_gadget_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a node of a phase gadget (phase or root) or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a node of a phase gadget (phase or root), false otherwise </dd></dl>

</div>
</div>
<a id="a4a66aa5faca974c4c25ccb74a2f4c0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a66aa5faca974c4c25ccb74a2f4c0a9">&#9670;&nbsp;</a></span>check_proper_clifford_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_proper_clifford_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a proper clifford spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a proper clifford spider, false otherwise </dd></dl>

</div>
</div>
<a id="a657567ef4cc9864e5f4393c421ac4200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657567ef4cc9864e5f4393c421ac4200">&#9670;&nbsp;</a></span>check_x_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_x_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a X spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a X spider, false otherwise </dd></dl>

</div>
</div>
<a id="a8960b1d730f0d7ae95bc6fdb97f015e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8960b1d730f0d7ae95bc6fdb97f015e1">&#9670;&nbsp;</a></span>check_z_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_z_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a Z spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a Z spider, false otherwise </dd></dl>

</div>
</div>
<a id="a94fe901d795572242540545aba8fe664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fe901d795572242540545aba8fe664">&#9670;&nbsp;</a></span>check_zero_phase_spider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::check_zero_phase_spider </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the node specified in this index is a zero phase spider or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node specified in this index is a zero phase spider, false otherwise </dd></dl>

</div>
</div>
<a id="a93a6cd8f0f824386f8c94b0e2fe5526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a6cd8f0f824386f8c94b0e2fe5526f">&#9670;&nbsp;</a></span>connect_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::connect_nodes </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="zx_8h.html#a313f1181cb769f2e489b6e35219287d1">ZXEdgeKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make an edge connected two nodes specified the indexes, and assign the kind to the edge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>kind of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace3e7c355c35e3af2272728baa9055c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3e7c355c35e3af2272728baa9055c0">&#9670;&nbsp;</a></span>degree_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::degree_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a degree of the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>degree of the node </dd></dl>

</div>
</div>
<a id="a9c28259b9d73227de7bed6eb8e7a2b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c28259b9d73227de7bed6eb8e7a2b23">&#9670;&nbsp;</a></span>extract_2q_connects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt; &gt; Sharqit::ZXDiagram::extract_2q_connects </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract 2Q connections from the frontier (for CZ optimization in the update_frontier function) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of pairs of the indexes </dd></dl>

</div>
</div>
<a id="a44a961b51bd598cb9abe573a45d67b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a961b51bd598cb9abe573a45d67b1d">&#9670;&nbsp;</a></span>gfusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::gfusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a gadget fusion algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a8ccbfdfca7986229324f1d8d3fb0826a" title="apply a gadget fusion algorithm for the nodes specified in the indexes">ZXDiagram::gfusion_one_time</a> </dd></dl>

</div>
</div>
<a id="a8ccbfdfca7986229324f1d8d3fb0826a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccbfdfca7986229324f1d8d3fb0826a">&#9670;&nbsp;</a></span>gfusion_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::gfusion_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a gadget fusion algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A_phase</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B_phase</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a44a961b51bd598cb9abe573a45d67b1d" title="apply a gadget fusion algorithm">ZXDiagram::gfusion</a> </dd></dl>

</div>
</div>
<a id="a2b3b032dc9dd63c1e5efc3e9fafc7d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3b032dc9dd63c1e5efc3e9fafc7d08">&#9670;&nbsp;</a></span>kind_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a54e98198a3a6549ebb7b154384a5a28d">ZXNodeKind</a> Sharqit::ZXDiagram::kind_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a kind of the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the node </dd></dl>

</div>
</div>
<a id="a79a7d5b4ac607783b611af43136cd071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a7d5b4ac607783b611af43136cd071">&#9670;&nbsp;</a></span>lcomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::lcomp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a local complimmentation algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a7437040102fd820b57837316cc4ec0cb" title="apply a local complimmentation algorithm for the node specified in the index">ZXDiagram::lcomp_one_time</a> </dd></dl>

</div>
</div>
<a id="a7437040102fd820b57837316cc4ec0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7437040102fd820b57837316cc4ec0cb">&#9670;&nbsp;</a></span>lcomp_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::lcomp_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a local complimmentation algorithm for the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a79a7d5b4ac607783b611af43136cd071" title="apply a local complimmentation algorithm">ZXDiagram::lcomp</a> </dd></dl>

</div>
</div>
<a id="ad4a03a71663ac33a076cea81f6c0396f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a03a71663ac33a076cea81f6c0396f">&#9670;&nbsp;</a></span>permutation_as_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::permutation_as_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add swap gates to reorder the swapped qubit indexes to the original order in process of extracting the quantum circuit </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qc</td><td>the quantum circuit that qubit indexes is swapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98914b21c0504caa093953755a405fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98914b21c0504caa093953755a405fe7">&#9670;&nbsp;</a></span>pivot1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::pivot1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot1 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a367d5e853e0e3fa902389995028675cc" title="apply a pivot1 algorithm for the nodes specified in the indexes">ZXDiagram::pivot1_one_time</a> </dd></dl>

</div>
</div>
<a id="a367d5e853e0e3fa902389995028675cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367d5e853e0e3fa902389995028675cc">&#9670;&nbsp;</a></span>pivot1_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::pivot1_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot1 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a98914b21c0504caa093953755a405fe7" title="apply a pivot1 algorithm">ZXDiagram::pivot1</a> </dd></dl>

</div>
</div>
<a id="af2d8caa625a45f2b36be6ab0e30b7945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d8caa625a45f2b36be6ab0e30b7945">&#9670;&nbsp;</a></span>pivot2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::pivot2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot2 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#afff83d1ade4f126f47e8ab3c61a3c41b" title="apply a pivot2 algorithm for the nodes specified in the indexes">ZXDiagram::pivot2_one_time</a> </dd></dl>

</div>
</div>
<a id="afff83d1ade4f126f47e8ab3c61a3c41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff83d1ade4f126f47e8ab3c61a3c41b">&#9670;&nbsp;</a></span>pivot2_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::pivot2_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot2 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#af2d8caa625a45f2b36be6ab0e30b7945" title="apply a pivot2 algorithm">ZXDiagram::pivot2</a> </dd></dl>

</div>
</div>
<a id="a9745272bf37c2591dc52de591f70160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9745272bf37c2591dc52de591f70160b">&#9670;&nbsp;</a></span>pivot3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Sharqit::ZXDiagram::pivot3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply a pivot3 algorithm </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#aa25fd543788b8b8030c7bc03903317be" title="apply a pivot3 algorithm for the nodes specified in the indexes">ZXDiagram::pivot3_one_time</a> </dd></dl>

</div>
</div>
<a id="aa25fd543788b8b8030c7bc03903317be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25fd543788b8b8030c7bc03903317be">&#9670;&nbsp;</a></span>pivot3_one_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::pivot3_one_time </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>idx_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply a pivot3 algorithm for the nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_A</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_B</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a9745272bf37c2591dc52de591f70160b" title="apply a pivot3 algorithm">ZXDiagram::pivot3</a> </dd></dl>

</div>
</div>
<a id="a2560f940a5d3a8834def6b84752f6728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2560f940a5d3a8834def6b84752f6728">&#9670;&nbsp;</a></span>process_frontier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::process_frontier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>opt_cz</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update the frontier spiders initially </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt_cz</td><td>optimize CZ or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a78505be31339d22ba90fff6cb3016870" title="extract quantum gates from the ZX-diagram and update the frontier spiders">ZXDiagram::update_frontier</a> </dd>
<dd>
<a class="el" href="classSharqit_1_1ZXDiagram.html#acdc821db28c10af7ee3d54bca5a8beab" title="update frontier spiders in the case that the frontier can&#39;t be updated because of invalid biadjacency...">ZXDiagram::update_frontier_pg</a> </dd></dl>

</div>
</div>
<a id="acce955f0b9eb8dbdd93dd3671b928c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce955f0b9eb8dbdd93dd3671b928c5b">&#9670;&nbsp;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a313f1181cb769f2e489b6e35219287d1">Sharqit::ZXEdgeKind</a> Sharqit::ZXDiagram::remove_edge </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove an edge between two nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index to be connected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index to be connected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the edge removed </dd></dl>

</div>
</div>
<a id="a25ab69ca055827a468490ada3b8aa5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ab69ca055827a468490ada3b8aa5a4">&#9670;&nbsp;</a></span>remove_edges_of_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::remove_edges_of_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove all edges connected to the node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f543725ae8d27a30b1999c56e29d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f543725ae8d27a30b1999c56e29d96e">&#9670;&nbsp;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zx_8h.html#a54e98198a3a6549ebb7b154384a5a28d">Sharqit::ZXNodeKind</a> Sharqit::ZXDiagram::remove_node </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>node_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove a node specified in the index </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_index</td><td>node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the node removed </dd></dl>

</div>
</div>
<a id="abd43b4fccb7bfecc596af864dd3fbfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd43b4fccb7bfecc596af864dd3fbfc2">&#9670;&nbsp;</a></span>row_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::row_operation </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>execute row operation for the two nodes specified in the indexes </p>
<p>from the edges of node(a) to the edges of node(b) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae74a75321753b50fa089fcc73568aa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74a75321753b50fa089fcc73568aa27">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::simplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simplify the ZX-diagram </p>
<p>apply the algorithm of local complimentation, pivot1, pivot2, pivot3, and gadget fusion, for graph-like diagram converted the original ZX-diagram </p>

</div>
</div>
<a id="afad25b0079e62dbe6036ab7bd8c8af16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad25b0079e62dbe6036ab7bd8c8af16">&#9670;&nbsp;</a></span>stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, uint32_t &gt; Sharqit::ZXDiagram::stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get stats of the ZX-diagram </p>
<dl class="section return"><dt>Returns</dt><dd>stats of the ZX-diagram </dd></dl>

</div>
</div>
<a id="aa09e2a045862929cc496881dc44eaa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09e2a045862929cc496881dc44eaa23">&#9670;&nbsp;</a></span>swap_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap two nodes specified in the indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada3b23c18d64d8ca65810af82f268ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3b23c18d64d8ca65810af82f268ec7">&#9670;&nbsp;</a></span>to_dot_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::to_dot_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save as a dot file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>dot file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ea0db4f999c0f9e3f554ec86c28029c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea0db4f999c0f9e3f554ec86c28029c">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sharqit::ZXDiagram::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a string of the <a class="el" href="classSharqit_1_1ZXDiagram.html" title="ZX-diagram.">ZXDiagram</a> object </p>
<dl class="section return"><dt>Returns</dt><dd>string of the ZX-diagram </dd></dl>

</div>
</div>
<a id="a566b72cce5ddf2299f6d6730913725c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566b72cce5ddf2299f6d6730913725c9">&#9670;&nbsp;</a></span>to_svg_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::to_svg_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save as a svg file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>svg file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78505be31339d22ba90fff6cb3016870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78505be31339d22ba90fff6cb3016870">&#9670;&nbsp;</a></span>update_frontier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::update_frontier </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>opt_cz</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract quantum gates from the ZX-diagram and update the frontier spiders </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt_cz</td><td>optimize CZ or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a2560f940a5d3a8834def6b84752f6728" title="update the frontier spiders initially">ZXDiagram::process_frontier</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>updated or not </dd></dl>

</div>
</div>
<a id="acdc821db28c10af7ee3d54bca5a8beab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc821db28c10af7ee3d54bca5a8beab">&#9670;&nbsp;</a></span>update_frontier_pg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sharqit::ZXDiagram::update_frontier_pg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSharqit_1_1QCirc.html">Sharqit::QCirc</a> &amp;&#160;</td>
          <td class="paramname"><em>qc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update frontier spiders in the case that the frontier can't be updated because of invalid biadjacency matrix related to the frontier </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frontier</td><td>indexes' vector of frontier spiders introduced in the process of extracting quantum circuit </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">qc</td><td>the quantum circuit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSharqit_1_1ZXDiagram.html#a2560f940a5d3a8834def6b84752f6728" title="update the frontier spiders initially">ZXDiagram::process_frontier</a> </dd>
<dd>
<a class="el" href="classSharqit_1_1ZXDiagram.html#a78505be31339d22ba90fff6cb3016870" title="extract quantum gates from the ZX-diagram and update the frontier spiders">ZXDiagram::update_frontier</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>updated or not </dd></dl>

</div>
</div>
<a id="a61675e2cd9aa777a2ffbb637436c2f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61675e2cd9aa777a2ffbb637436c2f30">&#9670;&nbsp;</a></span>update_node_places()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::update_node_places </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the vector of the node places </p>
<p>this function is always called after updating the ZX-diagram </p>

</div>
</div>
<a id="a57d01b0c9c7b99a598327305261bbf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d01b0c9c7b99a598327305261bbf9a">&#9670;&nbsp;</a></span>update_phase_gadget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::update_phase_gadget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the vector of the phase gadget </p>
<p>this function is always called after updating the ZX-diagram </p>

</div>
</div>
<a id="a54e9a629d1b9ef8afa0753474c2a6dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e9a629d1b9ef8afa0753474c2a6dbd">&#9670;&nbsp;</a></span>xor_hadamard_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::xor_hadamard_edge </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operate XOR by the hadamard edge between two nodes specified in these indexes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>node index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a658d4267cf74af398e8d723d7955ac43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d4267cf74af398e8d723d7955ac43">&#9670;&nbsp;</a></span>xor_hadamard_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Sharqit::ZXDiagram::xor_hadamard_edges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>node_indexes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operate XOR by the all hadamard edges composed by any pair of two nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_indexes</td><td>vector of the node indexes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="zx_8h_source.html">zx.h</a></li>
<li><a class="el" href="extract__qcirc_8cpp.html">extract_qcirc.cpp</a></li>
<li><a class="el" href="simplify_8cpp.html">simplify.cpp</a></li>
<li><a class="el" href="zxdiagram_8cpp.html">zxdiagram.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
