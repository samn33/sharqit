C++ライブラリ
============

## 簡単な例

Sharqitライブラリを呼び出す簡単なC++プログラムを作ってみることから始めてみましょう。
まず、以下のようなC++プログラムをコピペしてどこかのディレクトリに置いてみてください。

    $ cat sample.cpp
    #include "sharqit/sharqit.h"
    
    int main()
    {
      Sharqit::QCirc qc_in;
	  qc_in.t(1);
	  qc_in.h(0);
	  qc_in.h(1);
	  qc_in.cx(0,1);
	  qc_in.h(0);
	  qc_in.h(1);
	  qc_in.tdg(1);
	  qc_in.show();

      Sharqit::Optimizer opt;
      Sharqit::QCirc qc_out = opt.reduce_gates(qc_in, "zx");
      qc_out.show();
    
      return 0;
    }

これを、

    $ g++ -O4 -std=c++17 -L ~/lib -I ~/include -I /usr/include/eigen3 sample.cpp -lshrqt

のようにコンパイルすると、a.outという実行形式が作成されます。実行すると、

    $ ./a.out
    q[0] --H-----*--H------
    q[1] --T--H--X--H--T+--
    q[0] --X--
    q[1] --*--

のようになります。最初の2行が最適化前の量子回路で後の2行が最適化後の量子回路を表しています。
何をやっているかというと(言わずもがなかもしれませんが)、
Sharqitコマンドを説明したときに例として上げた量子回路の最適化プログラムを作成してみました、というわけです。

一応、プログラムの中身を説明します。一行目の

    #include "sharqit/sharqit.h"

で、Sharqitライブラリに対応したヘッダーファイルをインクルードします。main関数の中の

    Sharqit::QCirc qc_in;
	
で、SharqitのQCircクラスのオブジェクトを生成します。この時点で量子回路は空です。次の
	
	qc_in.t(1);
	qc_in.h(0);
	qc_in.h(1);
	qc_in.cx(0,1);
	qc_in.h(0);
	qc_in.h(1);
	qc_in.tdg(1);

で空の量子回路に順番に量子ゲートを追加していきます。

    qc_in.t(1).h(0).h(1).cx(0,1).h(0).h(1).tdg(1);

のようにメソッドチェーンで記述することもできます。
ここで、t,h,cx,tdgというメソッドを適用していますが引数に記載されている数字は適用したい量子ビット番号を表しています。
2量子ビットゲートの場合は引数が2つ必要です。
最初の引数が制御側の量子ビット番号で2番目の引数が標的側の量子ビット番号を表します。
作成した量子回路はshowメソッドで表示することができます。

    qc_in.show();

次に量子回路を最適化するOptimizerクラスのオブジェクトを生成します。

    Sharqit::Optimizer opt;

で良いです。最適化を実行するメソッドはreduce_gatesです。引数に最適化したい元になる量子回路オブジェクトを指定します。

    Sharqit::QCirc qc_out = opt.reduce_gates(qc_in, "zx");

第1引数に最適化したい元になる量子回路オブジェクトを指定します。
第2引数に最適化の手法("zx"または"pp")を指定します。"zx"はZXCalculus、"pp"はPhasePolynomialを表します。
返却値は最適化後の量子回路オブジェクトになるので、それをqc_outという変数で受けるようにします。最後に、

    qc_out.show();

で、結果の量子回路を表示します。以上です。

## 量子回路の作成

量子回路オブジェクトの作成にはいくつかの方法があります。

- 量子ゲートメソッドを追加していく方法
- 量子回路を記述したファイルを読み込む方法
- ランダムな量子回路を生成する方法

以下、順に説明します。

### 量子ゲートメソッドを追加していく方法

「簡単な例」で示した方法です。
例で示した量子ゲート以外に多数の量子ゲートに対応したメソッドが用意されています。

ベーシックな量子ゲートとして、以下が定義されています。

- x ... Xゲート
- z ... Zゲート
- s ... Sゲート
- sdg ... Sゲートのエルミート共役
- t ... Tゲート
- tdg ... Tゲートのエルミート共役
- h ... Hゲート
- rz ... RZゲート(Z軸まわりの回転ゲート)
- cx ... CNOTゲート
- cz ... CZゲート
- id ... 1量子ビットの恒等演算ゲート(何もしないゲート)
- id2 ... 2量子ビットの恒等演算ゲート(何もしないゲート)

Sharqitでは、あらゆる量子回路をこの量子ゲートによって内部的に表現するようにしています。
加えて、以下の量子ゲートに対応したメソッドを使うこともできます。
ベーシックな量子ゲートを組み合わせることで、これらメソッドを実現しています。

- y ... Yゲート
- rx ... RXゲート(X軸まわりの回転ゲート)
- ry ... RYゲート(Y軸まわりの回転ゲート)
- sx ... ルートXゲート(2乗するとXゲートになる)
- sxdg ... ルートXゲートのエルミート共役
- p ... 位相シフトゲート(グローバル位相を除きRZゲートと同等)
- cy ... 制御Yゲート
- csx ... 制御ルートXゲート
- csxdg ... 制御ルートXゲートのエルミート共役
- ch ... 制御Hゲート
- cs ... 制御Sゲート
- csdg ... 制御ルートXゲートのエルミート共役
- ct ... 制御Tゲート
- ctdg ... 制御Tゲートのエルミート共役
- crx ... 制御RXゲート
- cry ... 制御RYゲート
- crz ... 制御RZゲート
- cp ... 制御位相シフトゲート
- rxx ... イジングカップリングゲート(XX結合)
- ryy ... イジングカップリングゲート(YY結合)
- rzz ... イジングカップリングゲート(ZZ結合)
- sw ... swapゲート
- csw ... 制御swapゲート(フレドキンゲート)
- ccx ... 制御CNOTゲート(トフォリゲート)

これらメソッドの引数について説明します。
回転角指定のない1量子ビットゲートの場合の引数は1つで、適用する量子ビット番号を指定します。
回転角指定のない2量子ビットゲートの場合の引数は2つで、制御ビット番号、標的ビット番号の順に指定します。
回転角指定のない3量子ビットゲートであるccxゲートの場合の引数は3つで、制御ビット番号、制御ビット番号、標的ビット番号の順で指定します。
回転角指定のない3量子ビットゲートであるcswゲートの場合の引数は3つで、制御ビット番号、標的ビット番号、標的ビット番号の順で指定します
(2つの標的ビットを制御ビットに応じてスワップします)。
回転角の指定がある量子ゲートの場合、上記引数に加えて、最後に角度を指定する必要があります。

いくつかの例を示します。

    Sharqit::QCirc qc;
	// 角度PIを表すPhaseクラスのオブジェクト
    Sharqit::Phase PI("PI");
	// 回転角指定のない1量子ビットゲート
    qc.h(0);
    qc.t(0);
    // 回転角指定のない2,3量子ビットゲート
    qc.cx(0,1);
    qc.csw(0,1,2);
    qc.crx(1,2);
    // 回転角指定のある1,2量子ビットゲート
    qc.rz(2, 3*PI/4);
    qc.crx(1,2,PI/2);

回転角はPhaseクラスのオブジェクトとして定義します。典型的な使い方は、上に示したように、PIラジアンを

    Sharqit::Phase PI("PI");

のように定義して、3*PI/4, PI/2, -PI/4, ...のように指定するやり方です。それ以外にも、

    Sharqit::Phase phase(3,4); // 3*PI/4を表す
    Sharqit::Phase phase(-1,2); // -PI/2を表す

のように指定するやり方もあります。

### 量子回路を記述したファイルを読み込む方法

Sharqitコマンドで説明した量子回路ファイルを読み込んで、量子回路オブジェクトとする方法もあります。
以下のようなファイルがあるとします。

    $ cat sample.sqc
    T 1
    H 0
    H 1
    CX 0 1
    H 0
    H 1
    T+ 1

loadメソッドを使って、

    Sharqit::QCirc qc_in;
    qc_in.load("sample.sqc");

のようにすることで、ファイルに記述されたものと同じ量子回路オブジェクトが作成されます。

### ランダムな量子回路を生成する方法

量子回路の最適化の性能を評価したい場合、ランダムに発生させた量子ゲートからなる量子回路を作りたい場合があります。
Sharqitコマンドの--randオプションと同様のことをC++プログラム内で実行することができます。

例えば、5量子ビットでトータルのゲート数が20の量子回路を、XゲートとTゲートとCNOTゲートの比率を4:5:3として作成したい場合、
add_randomメソッドを使って、

    Sharqit::QCirc qc_in;
    qc_in.add_random(5, 20, {{"X", 4},{"T", 5},{"CX", 3}});

のようにします。指定する比率は小数であっても良いです。

## 量子回路図の表示

「簡単な例」で、

    qc_in.show();
	
のように実行しました。この例の場合

    q[0] --H-----*--H------
    q[1] --T--H--X--H--T+--

のようになりますが、非常に深い回路の場合、以下のように折り返して表示されます。

    q[0] --X--T-----X--X-----*-----X--*--T--*--X--*--T--T--------------X--*--*-----*--X--T-----X--T--T-- ...
    q[1] -----------*--*-----|--X--*--X--T--|-----X--T--T--------*--*-----X--|--T--X--|--T--T--*--T----- ...
    q[2] --T--T--T--------T--X--T--------X--X--------T--T--X--T--X--X--T-----X--T-----*--T--T-----T----- ...
    
    T--X-----*-----X--------*--T--------*--*--------X-----X--------X--T--*--*--------*--T--T-----*--X--- ...
    ------*--X-----|--X--T--X--X--T--T--|--|--T--X--------|--X-----|--T--X--X--*--T--X--T--T-----X--*--T ...
    ------X-----T--*--T--T-----T--------X--X-----*--T--T--*--*--T--*--T--------X--T-----T--T--T--------- ...
    
    --------*--X--*--------
    --*--T--|--*--X--X--X--
    --X-----X--------------

折返しの位置は、デフォルトでは100文字になっていますが、showメソッドの引数で指定することもできます。

    qc_in.show(50);

## 量子回路の統計情報の取得

statsメソッドによって、std::map<std::string, uint32_t>のオブジェクトが返ってきます。
文字列をキーとしたした整数値によって各種情報が表現されているので、各々を以下のようにして取得することがきます。

    Sharqit::QCirc qc_in;
    qc_in.t(1);
    qc_in.h(0);
    qc_in.h(1);
    qc_in.cx(0,1);
    qc_in.h(0);
    qc_in.h(1);
    qc_in.tdg(1);
    std::map<std::string, uint32_t> stats = qc_in.stats();
    std::cout << "X-count  = " << stats["x_count"] << std::endl;
    std::cout << "Z-count  = " << stats["z_count"] << std::endl;
    std::cout << "H-count  = " << stats["h_count"] << std::endl;
    std::cout << "S-count  = " << stats["s_count"] << std::endl;
    std::cout << "T-count  = " << stats["t_count"] << std::endl;
    std::cout << "RZ-count = " << stats["rz_count"] << std::endl;
    std::cout << "CX-count = " << stats["cx_count"] << std::endl;
    std::cout << "2Q-count = " << stats["2q_count"] << std::endl;
    std::cout << "gate-count = " << stats["gate_count"] << std::endl;
    std::cout << "depth      = " << stats["depth"] << std::endl;
    std::cout << "qubit_num  = " << stats["qubit_num"] << std::endl;

この場合、以下のように表示されます。

    X-count  = 0
    Z-count  = 0
    H-count  = 4
    S-count  = 0
    T-count  = 2
    RZ-count = 2
    CX-count = 1
    2Q-count = 1
    gate-count = 7
    depth      = 5
    qubit_num  = 2

## 量子回路の最適化

「簡単な例」で、

    Sharqit::QCirc qc_out = opt.reduce_gates(qc_in, "zx");

のように実行しました。ここでreduce_gatesメソッドの2番目の引数に"zx"が指定されているので、
ZX-calculusを用いた手法で最適化計算がなされます。
Phase Polynomialを用いた手法で最適化計算をしたい場合、以下のように2番目の引数に手法を指定します。

    Sharqit::QCirc qc_out = opt.reduce_gates(qc_in, "pp");


### 量子回路の等価判定

2つの量子回路が等価かどうか、量子回路クラスのis_equalメソッドで以下のように確認することができます。

    bool eq = qc_in.is_equal(qc_out);
    std::cout << std::boolalpha << eq << std::endl;

Sharqitコマンド同様、ひとつ注意点があります。
内部で量子回路を行列に展開して行列同士の等価判定を行っているため、
量子ビット数があまり大きな回路でこれを実行すると、
なかなか結果が返ってこなかったり、メモリが足りなくなることに起因したエラーが発生する可能性があります。

## 量子回路の保存

量子回路をSharqit独自のファイル形式で出力する場合、saveメソッドを使います。

    qc_out.save("bar.sqc");
	
また、量子回路イメージをSVG形式で出力することもできます。

    qc_out.to_svg_file("bar.svg");
